#!/usr/bin/env bash

set -e

shopt -s nullglob lastpipe
set -o pipefail

declare -r PROGRAM="${0##*/}"

declare -r DEFAULT_CONFIG_ROOT="$HOME"
declare -r CONFIG_ROOT="${GH_CONFIG_ROOT:-$DEFAULT_CONFIG_ROOT}"

declare -r CONFIG_FILE="$CONFIG_ROOT"/.gh

declare -r REPOS_FILE="$CONFIG_ROOT"/.gh-repos
declare -r OLD_REPOS_FILE="$CONFIG_ROOT"/.gh-repos.old

declare -r DIFF_FILE="$CONFIG_ROOT"/.gh.diff

declare -A COMMANDS=(
    [checkin]=gh_checkin
    [ci]=gh_checkin
    [clone]=gh_clone
    [commands]=gh_commands
    [edit]=gh_edit
    [h]=gh_help
    [help]=gh_help
    [refresh]=gh_refresh
    [wait]=gh_wait)

declare ECHO_COMMAND=false

declare PREVIEW=false

# Generic global variables to hold input and output from functions
declare -A INH=()
declare OUT="" OUT2="" OUT3="" OUT4="" OUT5="" OUT6=""
declare -a OUTA=() OUTA2=()
declare -A OUTH=() OUTH2=()

declare CURL_VERIFIED=false
declare JQ_VERIFIED=false

function Usage {
    local arg
    for arg in "$@"
    do
        printf "%s\n" "$arg"
    done

    cat <<EOF
Usage: $PROGRAM COMMAND [OPTION...] [ARG...]
Git and GitHub tool.

See '$PROGRAM help config' for how to set up config.

COMMANDS
  checkin|ci [OPTION...] [TITLE]
      Push local change to pull request and wait. See wait for options.
  clone PATTERN
      Clone ENDPOINT:OWNER/REPO matching PATTERN from $REPOS_FILE.
  commands
      Display available commands
  diff [-m] [OPT...]
      Diff HEAD with working directory, passing OPT to git diff. -m will diff
      against merge base (last common ancestor to origin/master and HEAD).
  edit
      Open all modified and added files in an editor (EDITOR must be set).
  help [config]
  load [P]
      Apply diff from ~/.gh.diff. If P is specified and refers to a file,
      use that path instead, otherwise assume P is a hostname and scp its
      ~/.gh.diff to localhost.
  refresh
      Read $CONFIG_FILE and generate $REPOS_FILE cache.
  save [-n NAME] [PATH...]
      Save diff to ~/.gh.diff, limited to PATH if present.  With -n, the diff is
      saved to the path NAME if it contains a "/", otherwise it is saved to
      ~/.gh.diff.NAME.
  stack
      Stack commands similar to 'git stash', see 'gh help stack' for more info.
  uncommit
      Undo last commit command, i.e. set HEAD to parent without touching wd.
  wait [OPTION...] [PR_URL]
      Wait for checks to pass.
      Options are applied if and after the checks pass:
       --approve|-A|+1, approve PR
       --assignee|-a ASSIGNEE, assign PR to ASSIGNEE
       --comment|-c COMMENT, add comment
       --merge|-m, merge pull request, delete branch, and check out master
       --ptal|-p, ask reviewers and assignees to take another look at the PR
       --reviewers|-r REVIEWERS, comma-separated list of reviewers
EOF

    exit 1
}

function UsageError {
    local command="$1"
    shift
    
    if test "$command" == ""
    then
        local command_text=" of 'gh'"
    else
        local command_text=" of 'gh $command'"
    fi

    Fail "Bad invocation$command_text: " "$@" \
         $'\n'"See '$PROGRAM help' for details"
}

function Fail {
    local arg
    for arg in "$@"
    do
        printf "%s" "$arg"
    done
    echo

    exit 1
}

function Format {
    local format="$1"
    shift

    local -A specifiers=()
    local assignment
    for assignment in "$@"
    do
        if ! [[ "$assignment" =~ ^([^=])=(.*)$ ]]
        then
            Fail "Bad specifier assignment '$assignment'"
        fi
        local specifier="${BASH_REMATCH[1]}"
        local value="${BASH_REMATCH[2]}"
        specifiers["$specifier"]="$value"
    done

    local text=""
    local state=normal
    local -i i=0
    for (( ; i < ${#format}; ++i ))
    do
        local char="${format:$i:1}"

        case "$state" in
            normal)
                case "$char" in
                    %) state=specifier ;;
                    *) text+="$char" ;;
                esac
                ;;
            specifier)
                case "$char" in
                    %)
                        text+="%"
                        state=normal
                        ;;
                    *)
                        # Some substitutions may be empty
                        text+="${specifiers[$char]}"
                        state=normal
                        ;;
                esac
                ;;
        esac
    done

    OUT="$text"
}

function SplitBy {
    local strings="$1"
    local separator="$2"

    local -a array=()

    # TODO: It may be easier to use IFS, but making sure it's unchanged on
    # return is painful.

    if (( ${#strings} > 0 ))
    then
        local suffix="$strings"
        while true
        do
            local string="${suffix%%$separator*}"

            # If suffix doesn't contain separator, string equals suffix. In
            # either case, it is correct to...
            array+=("$string")

            if test "$string" == "$suffix"
            then
                break
            fi

            local new_suffix="${suffix#$string$separator}"
            if test "$new_suffix" == "$suffix"
            then
                Fail "Internal error: Unable to split '$strings' by " \
                     "'$separator'"
            fi

            suffix="$new_suffix"
        done
    fi

    OUTA=("${array[@]}")
}

function Extract {
    local regex="$1"
    local format="$2"

    while read -r
    do
        if [[ "$REPLY" =~ $regex ]]
        then
            local specifiers=()
            local key
            for key in "${!BASH_REMATCH[@]}"
            do
                specifiers+=("$key=${BASH_REMATCH[$key]}")
            done

            Format "$format" "${specifiers[@]}"
            printf "%s\n" "$OUT"
        fi
    done
}

function EchoCommand {
    printf "%q" "$1"
    shift

    local arg
    for arg in "$@"
    do
        printf " %q" "$arg"
    done
    printf "\\n"
}

function MaybeEchoCommand {
    if $ECHO_COMMAND
    then
        EchoCommand "$@"
    fi
}

function Run {
    MaybeEchoCommand "$@"
    "$@"
}

function RunOrFail {
    if ! "$@"
    then
        echo -n "Command failed: "
        EchoCommand "$@"
        exit 1
    fi
}

function CaptureStd {
    local -a command=("$@")

    local out
    if ! out=$("${command[@]}" 2>&1)
    then
        Fail "Command '${command[*]}' failed unexpectedly: '$out'"
    fi

    OUT="$out"
}

function CaptureStdLines {
    CaptureStd "$@"
    local out="$OUT"

    local -a lines=()
    if (( ${#out} > 0 ))
    then
        mapfile -t lines <<< "$out"
    fi

    OUTA=("${lines[@]}")
}

function PrintLines {
    local arg
    for arg in "$@"
    do
        printf "%s\n" "$arg"
    done
}

function Sort {
    local -a elements=("$@")

    OUTA=()
    mapfile -t OUTA <<< "$(PrintLines "${elements[@]}" | sort)"
}

function Match {
    local __Match_regex="$1"
    local __Match_text="$2"
    shift 2

    [[ "$__Match_text" =~ $__Match_regex ]]
    local -i __Match_status="$?"

    if test "$__Match_status" == 0
    then
        local -i __Match_index=1
        local __Match_variable_name
        for __Match_variable_name in "$@"
        do
            if test "$__Match_variable_name" != ""
            then
                local -n __Match_variable="$__Match_variable_name"
                __Match_variable="${BASH_REMATCH[$__Match_index]}"
            fi
            __Match_index+=1
        done
    elif test "$__Match_status" != 1
    then
        Fail "Bad regular expression: '$__Match_regex'"
    fi

    return "$__Match_status"
}

# Set OUT to a "JSON string" with the value of $1
# 
# Example: The string 'unescaped' defined as follows:
#     local unescaped='This is a "good" example
#     over two lines'
# would be escaped by ToJsonString to:
#     OUT='"This a \"good\" example\nover two lines'
function ToJsonString {
    local string="$1"

    local json_string="$string"
    json_string="${json_string//\\/\\\\}"
    json_string="${json_string//\"/\\\"}"

    local newline=$'\n'
    json_string="${json_string//$newline/\\n}"

    local tab=$'\t'
    json_string="${json_string//$tab/\\t}"

    OUT="\"$json_string\""
}

function Jq {
    local jq_expression="$1"
    local json="$2"
    shift 2

    if ! $JQ_VERIFIED
    then
        if ! type -a jq &> /dev/null
        then
            Fail "'jq' is not installed"
        fi
        JQ_VERIFIED=true
    fi

    local out
    if ! out=$(jq "$@" "$jq_expression" <<< "$json" 2>&1)
    then
        Fail "'jq' with expression '$jq_expression' failed on json '$json' " \
             "printing '$out'"
    fi

    OUT="$out"
}

function JqRaw {
    Jq "$@" -r
}

function JqRawLines {
    local jq_expression="$1"
    local json="$2"

    JqRaw "$jq_expression" "$json"
    local out="$OUT"

    local -a lines=()

    if test "$out" != ""
    then
        while read -r
        do
            local line="$REPLY"
            lines+=("$line")
        done <<< "$out"
    fi

    OUTA=("${lines[@]}")
}

function ReadConfigAsString {
    if ! test -e "$CONFIG_FILE"
    then
        Fail "Please make a config file '$CONFIG_FILE'"
    fi

    OUT=$(< "$CONFIG_FILE")
}

function GetEndpoints {
    ReadConfigAsString
    local config="$OUT"

    JqRawLines ".endpoints | keys[]" "$config"
    # Forward OUTA
}

function ResolveEndpoint {
    local endpoint="$1"
    SanityCheckEndpoint "$endpoint"

    ReadConfigAsString
    local config="$OUT"

    ToJsonString "$endpoint"
    local name="$OUT"

    Jq ".endpoints.$endpoint" "$config"
    local json="$OUT"

    JqRaw .api_authority "$json"
    local api_authority="$OUT"
    local api_authority_regex='^[a-zA-Z0-9.:-]+$'
    if ! [[ "$api_authority" =~ $api_authority_regex ]]
    then
        Fail "Invalid api_authority found in $CONFIG_FILE for endpoint " \
             "'$endpoint': Is expected to match " \
             "'$api_authority_regex' but is '$api_authority'"
    fi

    JqRaw .user "$json"
    local user="$OUT"
    local user_regex='^[a-zA-Z0-9_-]+$'
    if ! [[ "$user" =~ $user_regex ]]
    then
        Fail "Invalid user found in $CONFIG_FILE for endpoint " \
             "'$endpoint': Is expected to match " \
             "'$user_regex' but is '$user'"
    fi

    JqRaw .token "$json"
    local token="$OUT"
    local token_regex='^[a-zA-Z0-9=]{40}$'
    if ! [[ "$token" =~ $token_regex ]]
    then
        Fail "Invalid token found in $CONFIG_FILE for endpoint " \
             "'$endpoint': Is expected to match " \
             "'$token_regex' but is '$token'"
    fi

    if test "$api_authority" == api.github.com
    then
        local rest_url="https://$api_authority"
        local graphql_url="https://$api_authority/graphql"
    else
        # WARNING: This is assuming GitHub Enterprise setup
        local rest_url="https://$api_authority/api/v3"
        local graphql_url="https://$api_authority/api/graphql"
    fi

    OUT="$rest_url"
    OUT2="$user"
    OUT3="$token"
    OUT4="$graphql_url"
}

function Curl {
    local url="$1"
    local token="$2"
    shift 2
    local -a args=("$@")

    if ! $CURL_VERIFIED
    then
        if ! type -a curl &> /dev/null
        then
            Fail "'curl' is not installed"
        fi
        CURL_VERIFIED=true
    fi

    local save_dir="$HOME/tmp/gh.cache"
    mkdir -p "$save_dir"

    # Note: Cannot use <<< with tr since it adds a newline
    local url_filename=$(printf "%s" "$url" | tr -c 'a-zA-Z0-9_-' '_')
    local command_file="$save_dir/$url_filename.command"
    local response_file="$save_dir/$url_filename.response"

    if $PREVIEW
    then
        local accept=application/vnd.github.thor-preview+json
    else
        local accept=application/vnd.github.v3+json
    fi

    local -a command=(
        curl
        --silent
        --fail
        --output "$response_file"
        --write-out "%{http_code}"
        -H "Content-Type: application/json"
        -H "Accept: $accept"
        -H "Authorization: token $token"
        "${args[@]}"
        "$url"
    )

    EchoCommand "${command[@]}" > "$command_file"
    # Avoid stale response_file in case it's not overwritten:
    rm -f "$response_file"

    local -i http_code=0
    MaybeEchoCommand "${command[@]}"
    if http_code=$("${command[@]}")
    then
        :
    else
        local -i status="$?"
        local message="Curl failed with status $status"

        if (( http_code > 0 ))
        then
            message+=" and HTTP status code $http_code"
        fi

        message+=" for command:"$'\n'$(< "$command_file")

        if test -e "$response_file"
        then
            local response=$(< "$response_file")
            if (( ${#response} > 0 ))
            then
                message+=$'\n'"With HTTP response body:"$'\n'"$response"
            else
                message+=$'\n'"With empty HTTP response body"
            fi
        else
            message+=$'\n'"With absent HTTP response body"
        fi

        Fail "$message"
    fi

    if (( http_code < 200 || http_code >= 300 ))
    then
        Fail "HTTP response code $http_code for command: ${command[*]}"
    fi

    local response
    if ! response=$(< "$response_file")
    then
        Fail "Failed to read '$response_file'"
    fi

    if ! Jq . "$response" &> /dev/null
    then
        Fail "Response is invalid JSON: '$response'"
    fi

    OUT="$response"
}

function CurlRest {
    local endpoint="$1"
    local path="$2" # E.g. /repos/user
    shift 2

    ResolveEndpoint "$endpoint"
    local rest_url="$OUT"
    local user="$OUT2"
    local token="$OUT3"

    local url="${rest_url%/}/${path#/}"

    Curl "$url" "$token" "$@"
}

function GetRest {
    CurlRest "$@" -X GET 
}

# Usage: PostRest ENDPOINT PATH -d '...' ...
function PostRest {
    CurlRest "$@" -X POST 
}

function PutRest {
    CurlRest "$@" -X PUT
}

function DeleteRest {
    CurlRest "$@" -X DELETE
}

function QueryGraph {
    local endpoint="$1"
    local query="$2"
    shift 2

    ToJsonString "$query"
    local query_json="$OUT"
    local json="{\"query\": $query_json}"

    ResolveEndpoint "$endpoint"
    local user="$OUT2"
    local token="$OUT3"
    local graphql_url="$OUT4"

    Curl "$graphql_url" "$token" "$@" -X POST -d "$json"
    # OUT="$response"
}

function QueryGraphList {
    local endpoint="$1"
    local query_prefix="$2"
    local query_suffix="$3"
    local jq_path="$4"
    shift 4

    local jq_nodes=""

    local cursor_text=""
    while true
    do
        local query="$query_prefix$cursor_text$query_suffix"
        QueryGraph "$endpoint" "$query" "$@"
        local response="$OUT"

        Jq "$jq_path" "$response"
        local graphql_array="$OUT"

        Jq '.nodes[]' "$graphql_array"
        jq_nodes+="$OUT"$'\n'

        Jq .pageInfo.hasNextPage "$graphql_array"
        local has_next_page="$OUT"
        case "$has_next_page" in
            true) : ;;
            false) break ;;
            *)
                Fail "Bad value of hasNextPage for GraphQL array " \
                     "'$graphql_array'"
                ;;
        esac

        Jq .pageInfo.endCursor "$graphql_array"
        local end_cursor_json="$OUT"
        cursor_text=" after:$end_cursor_json"
    done

    OUT="$jq_nodes"
}

function GetOrgs {
    local endpoint="$1"

    ResolveEndpoint "$endpoint"
    local user="$OUT2"

    ToJsonString "$user"
    local user_json="$OUT"

    local query="
query {
  user(login:$user_json) {
    organizations(first:100) {
      totalCount
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        name
        login
        url
      }
    }
  }
}
"

    QueryGraph "$endpoint" "$query"
    local orgs_json="$OUT"

    JqRawLines ".data.user.organizations.nodes[].login" "$orgs_json"
    local -a orgs=("${OUTA[@]}")

    OUTA=("${orgs[@]}")
}

function gh_orgs {
    if (( $# != 1 ))
    then
        UsageError orgs "Expected exactly one argument: the endpoint name"
    fi

    local endpoint="$1"

    GetOrgs "$endpoint"
    PrintLines "${OUTA[@]}"
}

function GetRepos {
    local endpoint="$1"
    local owner="$2" # organization or user
    
    local -a repos=()

    ToJsonString "$owner"
    local owner_json="$OUT"

    local after_text=""

    while true
    do
        local query="
query {
  repositoryOwner(login:$owner_json) {
    repositories(first:100$after_text) {
      pageInfo {
        endCursor
        hasNextPage
      }
      nodes {
        owner {
          login
        }
        name
      }
    }
  }
}"

        QueryGraph "$endpoint" "$query"
        local response_json="$OUT"

        # The weirdest thing: With owner_json being e.g. 'hakon', I get some
        # owner.login which are != 'hakon'. It's not clear why these extra
        # repositories are output. Depends on permissions?
        #
        # Therefore, we will select only those having .owner.login equal to
        # $owner.

        JqRawLines ".data.repositoryOwner.repositories.nodes[] | select(.owner.login == $owner_json) | .name" \
                   "$response_json"
        repos+=("${OUTA[@]}")

        JqRaw ".data.repositoryOwner.repositories.pageInfo.hasNextPage" \
              "$response_json"
        local has_next_page="$OUT"

        case "$has_next_page" in
            true) : ;;
            false) break ;;
            *) Fail "Bas hasNextPage value in response: '$has_next_page'" ;;
        esac

        JqRaw ".data.repositoryOwner.repositories.pageInfo.endCursor" \
              "$response_json"
        local end_cursor="$OUT"

        if ! Match '^[a-zA-Z0-9=]+$' "$end_cursor"
        then
            Fail "Bas endCursor value in response: '$end_cursor'"
        fi

        ToJsonString "$end_cursor"
        local end_cursor_json="$OUT"
        after_text=" after:$end_cursor_json"
    done

    OUTA=("${repos[@]}")
    Sort "${OUTA[@]}"
}

function GetStatus {
    Stage

    local -a files=()
    local -A file_statuses=()

    # The '.' will make git status ignore all modified files that are not in
    # . or below, i.e. there are no ../ paths. If a file is moved out from
    # (below) . to somewhere else in ../, it will be marked as D. And vice
    # versa.

    CaptureStdLines git status --short .
    local -a lines=("${OUTA[@]}")

    local line
    for line in "${lines[@]}"
    do
        if [[ "$line" =~ ^R'  '([^' ']+)' -> '([^' ']+)$ ]]
        then
            local from_path="${BASH_REMATCH[1]}"
            local to_path="${BASH_REMATCH[2]}"

            files+=("$from_path")
            files+=("$to_path")
            file_statuses["$from_path"]="D $to_path"
            file_statuses["$to_path"]="A $from_path"
        elif [[ "$line" =~ ^(.)'  '([^' ']+)$ ]]
        then
            local status="${BASH_REMATCH[1]}"
            local path="${BASH_REMATCH[2]}"
            files+=("$path")

            case "$status" in
                M|A|D) file_statuses["$path"]="$status" ;;
                *) Fail "Unknown git status '$status' for '$path'" ;;
            esac
        else
            Fail "Badly formatted status line, perhaps file path " \
                 "contains space or a rename? line: '$line'"
        fi
    done

    OUTA=("${files[@]}")
    CopyHashTo file_statuses OUTH
}

# Make the hash (associative array) named $1 a copy of the hash named $2.
# $1 and $2 MUST NOT be named one of: from_var_name, to_var_name, keys, or key.
function CopyHashTo {
    local from_var_name="$1"
    local to_var_name="$2"

    eval "$to_var_name=()"
    AddHashTo "$from_var_name" "$to_var_name"
}

# Add all key/value pairs in the hash (associative array) named $1 to the hash
# named $2.  $1 and $2 MUST NOT be named one of: from_var_name, to_var_name,
# keys, or key.
function AddHashTo {
    local from_var_name="$1"
    local to_var_name="$2"

    eval "local -a keys=(\"\${!$from_var_name[@]}\")"

    local key
    for key in "${keys[@]}"
    do
        eval "$to_var_name[$key]=\"\${$from_var_name[$key]}\""
    done
}

function SelectFiles {

    local -i current_index=0
    local -A selected_files=()
    local action=""

    local -a files=()
    local -i num_files=0
    local -A file_statuses=()
    local need_get_status=true

    local selection_done=false
    while ! $selection_done
    do
        if $need_get_status
        then
            GetStatus
            files=("${OUTA[@]}")
            CopyHashTo OUTH file_statuses
            need_get_status=false

            num_files="${#files[@]}"
            if (( num_files <= 0 ))
            then
                current_index=0
                selection_done=true
                continue
            elif (( current_index >= num_files ))
            then
                current_index=$(( num_files - 1 ))
            fi
        fi

        local curren_file=""

        local -i index=0
        local file
        for file in "${files[@]}"
        do
            if test "$current_index" == "$index"
            then
                local marker='>'
                local rmarker='<'
                current_file="$file"
            else
                local marker=' '
                local rmarker=' '
            fi

            if test "${selected_files[$file]}" == ""
            then
                local selected=' '
            else
                local selected='X'
            fi

            local status="${file_statuses[$file]:0:1}"
            local other_file="${file_statuses[$file]:2}"
            if (( ${#other_file} > 0 ))
            then
                if test "$status" == A
                then
                    local annotation=" (<- $other_file)"
                else
                    local annotation=" (-> $other_file)"
                fi
            else
                local annotation=""
            fi

            printf "%s%s %2d %s %s%s %s\\n" \
                   "$marker" \
                   "$selected" \
                   "$index" \
                   "$status" \
                   "$file" \
                   "$annotation" \
                   "$rmarker"
            index+=1
        done

        printf "%s" \
               "(d)iff, (h)elp, down/up (j/k), (q)uit, (r)evert, select (x)/(a)ll, (s)tash. "
        local command=""
        while true
        do
            read -n 1 -r || true
            if test "$REPLY" == ""
            then
                break
            else
                command+="$REPLY"
                if [[ "$command" =~ ^[0-9-]+$ ]]
                then
                    continue
                fi
                echo # User types a single-letter command, so insert newline
                break # Single-letter command, interpret below
            fi
        done

        if [[ "$command" =~ ^([0-9]+)(-([0-9]+))?$ ]]
        then
            local start_index="${BASH_REMATCH[1]}"
            local last_index="${BASH_REMATCH[3]}"
            if test "$last_index" == ""
            then
                # Do not mark when only a single number was written?
                last_index="$start_index"
            else
                local -i i=start_index
                for ((; i <= last_index; ++i))
                do
                    local file="${files[$i]}"
                    if test "${selected_files[$file]}" == ""
                    then
                        selected_files["$file"]=1
                    else
                        unset selected_files\["$file"\]
                    fi
                    
                    start_index=$(( last_index + 1 ))
                done
            fi

            current_index="$last_index"
            if (( current_index >= num_files ))
            then
                current_index=$(( num_files - 1 ))
            fi
        else
            case "$command" in
                a)
                    # select all
                    local -i num_selected=0
                    local file
                    for file in "${files[@]}"
                    do
                        if test "${selected_files[$file]}" != ""
                        then
                            num_selected+=1
                        fi
                    done

                    if (( num_selected < num_files ))
                    then
                        for file in "${files[@]}"
                        do
                            selected_files["$file"]=1
                        done
                    else
                        for file in "${files[@]}"
                        do
                            unset selected_files\["$file"\]
                        done
                    fi
                    ;;
                d)
                    # diff
                    if (( "${#selected_files[@]}" == 0 ))
                    then
                        git diff HEAD -- "$current_file"
                    else
                        git diff HEAD -- "${!selected_files[@]}"
                    fi
                    ;;
                h)
                    # help
                    cat <<EOF
diff, revert, stash: operates on current if none are selected.
EOF
                    ;;
                j)
                    # down
                    if (( current_index + 1 < num_files ))
                    then
                        current_index+=1
                    fi
                    ;;
                k)
                    # up
                    if (( current_index > 0 ))
                    then
                        current_index+=-1
                    fi
                    ;;
                q)
                    # quit
                    selection_done=true
                    action=quit
                    ;;
                r)
                    # revert selected files
                    if (( "${#selected_files[@]}" == 0 ))
                    then
                        local -a fs=("$current_file")
                    else
                        local -a fs=("${!selected_files[@]}")
                    fi

                    local file
                    for file in "${fs[@]}"
                    do
                        local status="${file_statuses[$file]:0:1}"
                        case "$status" in
                            M|D)
                                Run git reset -q HEAD "$file"
                                Run git checkout -q "$file"
                                ;;
                            A)
                                Run git reset -q HEAD "$file"
                                Run rm "$file"
                                ;;
                            R)
                                # Note: R is made into separate A and D. Should
                                # not get here.
                                Fail "Modifications on renamed files is not yet supported"
                                ;;
                            *) Fail "Unknown status '$status' for file '$file'"
                        esac
                    done

                    # Trigger another git status command to refresh file view
                    need_get_status=true
                    ;;
                s)
                    # stash selected files
                    if (( "${#selected_files[@]}" == 0 ))
                    then
                        local -a fs=("$current_file")
                    else
                        local -a fs=("${!selected_files[@]}")
                    fi

                    # git stash push -- <pathspec>... will stash pathspec PLUS
                    # ALL FILES IN INDEX. -u is necessary to include untracked
                    # files, if any as given by fs..
                    git reset -q HEAD
                    echo git stash push -u -- "${fs[@]}"
                    RunOrFail git stash push -u -- "${fs[@]}"
                    Stage

                    # Trigger another git status command to refresh file view
                    selected_files=()
                    current_index=0
                    need_get_status=true
                    
                    ;;
                x)
                    if test "${selected_files[$current_file]}" == ""
                    then
                        selected_files["$current_file"]=1
                    else
                        unset selected_files\["$current_file"\]
                    fi
                    if (( current_index + 1 < num_files ))
                    then
                        current_index+=1
                    fi
                    ;;
                y|'')
                    # yes/confirmed ('' comes from user hitting enter)
                    selection_done=true
                    ;;
            esac
        fi
    done

    # To get the ordering right, we need to loop over files
    local selected_files_array=()
    local file
    for file in "${files[@]}"
    do
        if test "${selected_files[$file]}" != ""
        then
            selected_files_array+=("$file")
        fi
    done

    OUT="$action"
    OUTA=("${selected_files_array[@]}")
    OUTA2=("${files[@]}")
    CopyHashTo selected_files OUTH
    CopyHashTo file_statuses OUTH2
}

function PrintHash {
    local PrintHash_varname="$1"

    eval "local -a PrintHash_keys=(\"\${!$PrintHash_varname[@]}\")"

    echo "$PrintHash_varname=("
    local PrintHash_key
    for PrintHash_key in "${PrintHash_keys[@]}"
    do
        eval "local PrintHash_value=\"\${$PrintHash_varname[\$PrintHash_key]}\""
        printf "  [%q]=%q\n" "$PrintHash_key" "$PrintHash_value"
    done
    echo ")"
}

function gh_queue {
    # gh_branch --full
    gh i
    git stash list
}

function gh_menu {
    SelectFiles
    local -a files=("${OUTA[@]}")
    local -A statuses=()
    CopyHashTo OUTH2 statuses
}

function gh_repos {
    if (( $# != 2 ))
    then
        UsageError repos "Command takes exactly two arguments"
    fi

    local endpoint="$1"
    local owner="$2"

    GetRepos "$endpoint" "$owner"
    PrintLines "${OUTA[@]}"
}

function gh_refresh {
    if (( $# != 0 ))
    then
        UsageError refresh "Takes exactly 0 arguments"
    fi

    local repos_workfile="$HOME/.gh-repos.tmp"
    > "$repos_workfile"

    GetEndpoints
    local -a endpoints=("${OUTA[@]}")

    local endpoint
    for endpoint in "${endpoints[@]}"
    do
        if [[ "$endpoint" =~ ' ' ]]
        then
            Fail "The file format assumes endpoint '$endpoint' doesn't " \
                 "doesn't contains space"
        fi

        GetOrgs "$endpoint"
        local -a orgs=("${OUTA[@]}")

        ResolveEndpoint "$endpoint"
        local user="$OUT2"

        local -a owners=("$user" "${orgs[@]}")

        # Hack:
        #  - GraphQL DOESN'T support providing ssh_url for a repo.
        #  - So we must use REST API.
        #  - Either we list all repos with heavy-weight REST API, or
        #  - as we choose to do, we get ssh_url for one repo per endpoint,
        #    and guess the ssh_url for all others.
        local ssh_url_prefix="" ssh_url_suffix=""

        local owner
        for owner in "${owners[@]}"
        do
            if [[ "$owner" =~ ' ' ]]
            then
                Fail "The file format assumes owner '$owner' doesn't " \
                     "doesn't contains space"
            fi

            GetRepos "$endpoint" "$owner"
            local -a repos=("${OUTA[@]}")

            if (( ${#repos[@]} == 0 ))
            then
                # No point in proceeding
                continue
            fi

            if test "$ssh_url_prefix" == ""
            then
                local example_repo="${repos[0]}"
                GetRest "$endpoint" "/repos/$owner/$example_repo"
                local json="$OUT"

                JqRaw .ssh_url "$json"
                local ssh_url="$OUT"

                # This is a terrible regex.
                local regex="^(.*)$owner/$example_repo(.*)"
                if ! Match "$regex" "$ssh_url" \
                     ssh_url_prefix ssh_url_suffix
                then
                    Fail "Unexpected form of ssh_url doesn't match regex " \
                         "'$regex': '$ssh_url'"
                fi
            fi

            local repo
            for repo in "${repos[@]}"
            do
                if [[ "$repo" =~ ' ' ]]
                then
                    Fail "The file format assumes repo '$repo' doesn't " \
                         "doesn't contains space"
                fi

                local ssh_url="${ssh_url_prefix}$owner/$repo$ssh_url_suffix"

                if [[ "$ssh_url" =~ ' ' ]]
                then
                    Fail "The file format assumes ssh_url '$ssh_url' doesn't " \
                         "doesn't contains space"
                fi

                printf "%s %s %s %s\n" "$endpoint" "$owner" "$repo" "$ssh_url" \
                       >> "$repos_workfile"
            done
        done
    done

    if test -e "$REPOS_FILE"
    then
        cp "$REPOS_FILE" "$OLD_REPOS_FILE"
    fi
    sort "$repos_workfile" > "$REPOS_FILE"
    rm "$repos_workfile"
}

function GitHubInfoFromOrigin {
    # Unfortunately get-url isn't supported by git on RHEL 7, so we have to
    # extract URL from 'git remote -v'.
    local remote_url
    local fetch_url_regex='^origin'$'\t''(.*) \(fetch\)$'
    if ! remote_url=$(git remote -v | Extract "$fetch_url_regex" "%1")
    then
        Fail "Failed to get origin remote URL"
    fi

    AssertReposFile

    local endpoint="" owner="" repo="" ssh_url=""
    while read -r endpoint owner repo ssh_url
    do
        if test "$ssh_url" == "$remote_url"
        then
            OUT="$endpoint"
            OUT2="$owner"
            OUT3="$repo"
            OUT4="$ssh_url"
            return
        fi
    done < "$REPOS_FILE"

    Fail "Failed to find any repositories matching current git repo"
}            

function gh_rest {
    if (( $# < 2 ))
    then
        UsageError rest "Takes at least 2 arguments"
    fi

    local endpoint="$1"
    local path="$2"
    shift 2

    GetRest "$endpoint" "$path" "$@"
    printf "%s\n" "$OUT"
}

function AssertReposFile {
    if ! test -r "$REPOS_FILE"
    then
        Fail "Repository summary file not generated, please run " \
             "'gh refresh'"
    fi
}

function SanityCheckEndpoint {
    local endpoint="$1"

    local endpoint_regex='^[a-zA-Z0-9_-]+$'
    if ! [[ "$endpoint" =~ $endpoint_regex ]]
    then
        Fail "Bad endpoint '$endpoint': Must match '$endpoint_regex'"
    fi
}

function SanityCheckOwner {
    local owner="$1"

    local owner_regex='^[a-zA-Z0-9_-]+$'
    if ! [[ "$owner" =~ $owner_regex ]]
    then
        Fail "Bad owner '$owner': Must match '$owner_regex'"
    fi
}

function SanityCheckRepo {
    local repo="$1"

    local repo_regex='^[a-zA-Z0-9_-]+$'
    if ! [[ "$repo" =~ $repo_regex ]]
    then
        Fail "Bad repo '$repo': Must match '$repo_regex'"
    fi
}

function ValidateRepo {
    SanityCheckEndpoint "$1"
    SanityCheckOwner "$2"
    SanityCheckRepo "$3"
}

function PrintCommandsOfUnsorted {
    # Maps a command function to a space-separated list of commands
    local -A commands_by_function=()

    local table
    for table in "$@"
    do
        # "$table" expands to e.g. "COMMANDS"
        eval "local -a commands=(\"\${!$table[@]}\")"
        local command
        for command in "${commands[@]}"
        do
            eval "local func=\"\${$table[$command]}\""

            if ! [[ "$func" =~ ^[a-zA-Z0-9_]+$ ]]
            then
                Fail "Internal error: Bad function name '$func'"
            fi

            if test "${commands_by_function[$func]}" == ""
            then
                commands_by_function["$func"]+="$command"
            else
                commands_by_function["$func"]+=" $command"
            fi
        done
    done

    local func
    for func in "${!commands_by_function[@]}"
    do
        # Poor man's sorting...

        local -i max_length=0
        local -A by_length=()

        local command
        # yes, commands_by_function is supposed to be unescaped
        for command in ${commands_by_function["$func"]}
        do
            local -i length="${#command}"
            # Again, poor man's sorting. Try to print proper commands first,
            # then long options, then short options.
            case "$command" in
                --*) length+=10 ;;
                -*) length+=0 ;;
                *) length+=20 ;;
            esac
            if (( length > max_length ))
            then
                max_length=length
            fi

            if test "${by_length[$length]}" != ""
            then
                Fail "Internal error: length of equivalent commands " \
                     "'$command' and '${by_length[$length]}'"
            fi
            by_length["$length"]="$command"
        done

        printf "%q" "${by_length[$max_length]}"

        local -i length=$(( max_length - 1 ))
        while (( length > 0 ))
        do
            local command="${by_length[$length]}"
            if test "$command" != ""
            then
                printf ", %q" "${by_length[$length]}"
            fi
            length=$(( length - 1 ))
        done

        printf "\n"
    done
}

function PrintCommandsOf {
    if test -t 1
    then
        PrintCommandsOfUnsorted "$@" | sort | pr -4 -w 80 -t
    else
        PrintCommandsOfUnsorted "$@" | sort
    fi
}

function gh_commands {
    local -i verbosity=0

    while (( $# > 0 ))
    do
        case "$1" in
            -v) verbosity+=1 ;;
            -vv) verbosity+=2 ;;
            *) UsageError commands "Unknown argument '$1'" ;;
        esac
        shift
    done

    case "$verbosity" in
        0) PrintCommandsOf COMMANDS ;;
        1) PrintCommandsOf COMMANDS UNOFFICIAL_COMMANDS ;;
        *) PrintCommandsOf COMMANDS UNOFFICIAL_COMMANDS DANGEROUS_COMMANDS ;;
    esac
}

function gh_clone {
    if (( $# == 0 ))
    then
        UsageError clone "No pattern given"
    fi
    local pattern="$1"

    local destination=""
    if (( $# > 1 ))
    then
        destination="$2"
        if (( $# > 2 ))
        then
            UsageError clone "Too many arguments"
        fi
    fi

    AssertReposFile

    local -a matched_specs=()
    local -a matched_lines=()
    local endpoint owner repo ssh_url
    while read -r endpoint owner repo ssh_url
    do
        local spec="$endpoint:$owner/$repo"
        if [[ "$spec" =~ $pattern ]]
        then
            matched_specs+=("$spec")
            matched_lines+=("$endpoint $owner $repo $ssh_url")
        fi
    done < "$REPOS_FILE"

    local -i num_matches="${#matched_lines[@]}"
    case "$num_matches" in
        0)
            Fail "Pattern '$pattern' didn't match any 'owner/repositories', " \
                 "see $REPOS_FILE for the list of all repositories"
            ;;
        1) : ;;
        *)
            local message=""
            local spec
            for spec in "${matched_specs[@]}"
            do
                message+=$'\n'"$spec"
            done
            Fail "Too many repository specs matched '$pattern':$message"
            ;;
    esac

    read -r endpoint owner repo ssh_url <<< "${matched_lines[0]}"

    ValidateRepo "$endpoint" "$owner" "$repo"

    if test "$destination" == ""
    then
        destination="$endpoint/$owner/$repo"
    fi

    Run git clone "$ssh_url" "$destination"
}

function gh_help {
    if (( $# == 0 ))
    then
        Usage
    fi

    local topic="$1"
    shift

    local help_function=gh_help_"$topic"
    if ! declare -f "$help_function" &> /dev/null
    then
        UsageError help "Unknown help topic '$topic'"
    fi

    "$help_function" "$@"
}

function gh_help_config {
    cat <<EOF
The config file .gh should be defined in, and the repo cache .gh-repos is saved
in, the config root directory.  The config root is by default
$DEFAULT_CONFIG_ROOT, but can be overridden by setting GH_CONFIG_ROOT.

Example config:
{
    "endpoints": {
        "github": {
            "api_authority": "api.github.com",
            "user": "hakonhall",
            "token": "7fe3...",
            "owners": {
                "vespa-engine": {
                    "checks": [
                        "^cla/licenses\$"
                    ]
                    "repos": {
                        "vespa": {
                            "checks": [
                                "^continuous-integration/travis-ci/pr\$",
                                "^cla/licenses$"
                            ]
                        }
                    }
                }
            }
        }
    }
}

"token" is a personal access token.
"checks" can be put either at root level, in an endpoint, in an owner, or in a
repo.
EOF
}

function GetBranch {
    if ! OUT=$(git rev-parse --abbrev-ref HEAD)
    then
        Fail "Failed to get branch with 'git rev-parse --abbrev-ref HEAD'"
    fi
}

function gh_info {
    if (( $# != 0 ))
    then
        UsageError info "Command takes exactly zero arguments"
    fi

    gh_branch --full
    Stage
    GIT_PAGER="less -F -X" git diff --stat HEAD
}

function gh_load {
    local diff_file="$DIFF_FILE"

    if (( $# > 0 ))
    then
        if test -r "$1" && (( $# == 1 ))
        then
            diff_file="$1"
        else
            local -a scp_options=()
            while test "${1:0:1}" == -
            do
                scp_options+=("$1")
                shift
            done

            if (( $# == 0 ))
            then
                UsageError load "Missing hostname argument"
            elif (( $# > 1 ))
            then
                UsageError load "Too many arguments"
            fi
            local hostname="$1"

            rm -f "$DIFF_FILE"

            RunOrFail scp "${scp_options[@]}" "$hostname:$DIFF_FILE" "$DIFF_FILE"
        fi
    fi

    if ! test -r "$diff_file"
    then
        Fail "There is no diff file at $diff_file"
    fi

    if RunOrFail git apply "$diff_file"
    then
        echo "$diff_file has been applied"
    else
        Fail "Failed to load $diff_file"
    fi
}

function PendingUpstreamCommits {
    local branch="$1"

    local upstream=""
    if ! upstream=$(git rev-parse --symbolic-full-name "$branch"@{upstream} \
                        2>/dev/null)
    then
        Fail "Current branch '$branch' doesn't track any upstream"
    fi

    if ! [[ "$upstream" =~ ^refs/remotes/origin/ ]]
    then
        Fail "Upstream of current branch ($branch) is not at 'origin' " \
             "remote: refuse to run"
    fi

    RunOrFail git fetch --quiet origin

    OUT="$upstream"
    OUT2="$branch"
}

function gh_pending {
    local branch

    case "$#" in
        0)
            GetBranch
            branch="$OUT"
            ;;
        1) branch="$1" ;;
        *) UsageError pending "Too many arguments" ;;
    esac

    PendingUpstreamCommits "$branch"
    local upstream="$OUT"

    CaptureStd git rev-list --count "$branch".."$upstream"
    local -i pending_commits="$OUT"

    case "$pending_commits" in
        0) echo "There are no pending upstream commits" ;;
        1) echo "There us 1 pending upstream commit" ;;
        *) echo "There are $pending_commits pending upstream commits" ;;
    esac
}

function PullRequestInfo {
    local pr_id="$1"

    local wrong_usage=true
    if [[ "$pr_id" =~ ^[0-9]+$ ]]
    then
        local number="$pr_id"

        GitHubInfoFromOrigin
        local endpoint="$OUT"
        local owner="$OUT2"
        local repo="$OUT3"
        
        if TryGetPullRequest "$endpoint" "$owner" "$repo" "$number"
        then
            local branch="$OUT"
            local -a assignees=("${OUTA[@]}")
            local -a reviewers=("${OUTA2[@]}")
            wrong_usage=false
        fi
    elif FindEndpointIfPullRequestUrl "$pr_id"
    then
        local endpoint="$OUT"
        local owner="$OUT2"
        local repo="$OUT3"
        local number="$OUT4"
        local branch="$OUT5"
        local -a assignees=("${OUTA[@]}")
        local -a reviewers=("${OUTA2[@]}")
        wrong_usage=false
    fi

    if $wrong_usage
    then
        return 1
    else
        OUT="$endpoint"
        OUT2="$owner"
        OUT3="$repo"
        OUT4="$branch"
        OUT5="$number"
        OUTA=("${assignees[@]}")
        OUTA2=("${reviewers[@]}")
        return 0
    fi
}

function gh_pr {
    GitHubInfoFromOrigin
    local endpoint="$OUT"
    local owner="$OUT2"
    local repo="$OUT3"
    local ssh_url="$OUT4"

    GetBranch
    local branch="$OUT"

    if ! GetPullRequestNumber "$endpoint" "$owner" "$repo" "$branch"
    then
        UsageError pr "There's no PR number associated with working directory"
    fi
    local number="$OUT"
    local url="$OUT2"

    printf "%s\n" "$url"
}

function gh_resolve_pr {
    local format=$'endpoint: %e\nowner: %o\nrepo: %r\nnumber: %n\nassignees: %a\nreviewers: %R\n'
    while (( $# > 0 ))
    do
        case "$1" in
            -f|--format)
                format="$2"
                shift 2
                ;;
            *) break ;;
        esac
    done

    if (( $# == 0 ))
    then
        UsageError resolve-pr "Missing URL or number of pull request"
    elif (( $# > 1 ))
    then
        UsageError resolve-pr "Too many arguments"
    fi
    local pull_request_url_or_number="$1"

    if PullRequestInfo "$pull_request_url_or_number"
    then
        Format "$format" e="$OUT" o="$OUT2" r="$OUT3" b="$OUT4" n="$OUT5" \
               a="${OUTA[*]}" R="${OUTA2[*]}"
        printf "%s" "$OUT"
    else
        Fail "Failed to find pull request identified by " \
             "'$pull_request_url_or_number'"
    fi
}

function gh_resolve_wd {
    local format=$'endpoint: %e\nowner: %o\nrepo: %r\nbranch: %b\nssh-url: %s\n'
    while (( $# > 0 ))
    do
        case "$1" in
            -f|--format)
                format="$2"
                shift 2
                ;;
            *) break ;;
        esac
    done

    if (( $# > 0 ))
    then
        UsageError resolve-wd "Too many arguments"
    fi

    GitHubInfoFromOrigin
    local endpoint="$OUT"
    local owner="$OUT2"
    local repo="$OUT3"
    local ssh_url="$OUT4"

    GetBranch
    local branch="$OUT"

    Format "$format" e="$endpoint" o="$owner" r="$repo" b="$branch" s="$ssh_url"
    printf "%s" "$OUT"
}

function gh_revert {
    if (($# == 0))
    then
        Run git reset --quiet --hard
        # Resetting an added file/directory leaves it as untracked, so we need
        # to clean. Unfortunately, cleaning may also remove already untracked
        # files.
        # -f:  Force
        # -d:  Remove directories
        Run git clean --quiet -fd
    else
        # TODO: For each file in "$@", we should check it's status: whether
        # it's added, modified, deleted (, attribute change?), and this may be
        # different in wd vs index. The result of each such file should be an
        # action, like remove file from index and wd.

        Stage

        local -A file_status=()

        CaptureStdLines git status --short
        local -a lines=("${OUTA[@]}")

        local line
        for line in "${lines[@]}"
        do
            if [[ "$line" =~ ^(R)'  '([^' ']+)' -> '([^' ']+)$ ]]
            then
                local status="${BASH_REMATCH[1]}"
                local from_path="${BASH_REMATCH[2]}"
                local to_path="${BASH_REMATCH[3]}"

                from_path=$(realpath -m "$from_path")
                file_status["$from_path"]="$status"

                to_path=$(realpath -m "$to_path")
                file_status["$to_path"]="$status"
            elif [[ "$line" =~ ^(.)'  '([^' ']+)$ ]]
            then
                local status="${BASH_REMATCH[1]}"
                local path="${BASH_REMATCH[2]}"
                path=$(realpath -m "$path")

                case "$status" in
                    M|A|D) file_status["$path"]="$status" ;;
                    *) Fail "Unknown git status '$status' for '$path'" ;;
                esac
            else
                Fail "Badly formatted status line, perhaps file path " \
                     "contains space or a rename? line: '$line'"
            fi
        done

        local path
        for path in "$@"
        do
            path=$(realpath -m "$path")

            local status="${file_status[$path]}"
            case "$status" in
                M|D)
                    Run git reset -q HEAD "$path"
                    Run git checkout -q "$path"
                    ;;
                A)
                    Run git reset -q HEAD "$path"
                    Run rm "$path"
                    ;;
                R)
                    Fail "Modifications on renamed files is not yet supported"
                    ;;
                *) Fail "There's a path mismatch!?"
            esac
        done
    fi
}

function gh_save {
    local diff_file="$DIFF_FILE"

    while (( $# > 0 ))
    do
        case "$1" in
            -n)
                if [[ "$2" =~ / ]]
                then
                    diff_file="$2"
                    local parent_dir=$(dirname "$diff_file")
                    if ! test -d "$parent_dir"
                    then
                        Fail "Parent directory of '$diff_file' doesn't exist"
                    fi
                else
                    diff_file=~/.gh.diff."$2"
                fi
                shift 2
                ;;
            -*) Fail "Unknown option '$1'" ;;
            *) break ;;
        esac
    done

    Stage
    git diff HEAD "$@" > "$diff_file"
    echo "Saved to $diff_file"
}

function gh_stack {
    local command="${1:-showall}"
    shift || true

    case "$command" in
        di|diff) gh_stack_diff "$@" ;;
        drop|remove|rm) gh_stack_drop "$@" ;;
        l|ls|list) gh_stack_list "$@" ;;
        showall) gh_stack_showall "$@" ;;
        push) gh_stack_push "$@" ;;
        pop) gh_stack_pop "$@" ;;
        s|show) gh_stack_show "$@" ;;
        *) UsageError stack "Unknown subcommand '$command'" ;;
    esac
}

function gh_help_stack {
    cat <<EOF
Usage: gh stack [SUBCOMMAND [ARG...]]
Operate on a stack of pending commits

The default subcommand is showall.

SUBCOMMAND:
  diff [ID]
      Diff stack number ID, 0-offset
  drop [ID]
      Drop stack number ID, 0-offset
  showall
      Show all stack elements
  pop [ID]
      Apply and drop stack element ID, 0-offset
  push [FILE...]
      Push a commit on the stack containing the given files, or all modifications
  show [ID]
      Show summary stats on stack element ID, 0-offset
EOF
}

function ParseStackElementId {
    local command="$1"

    local -a args=()

    if (( $# > 0 ))
    then
        if ! [[ "$1" =~ ^[0-9]+$ ]]
        then
            UsageError "$command" "diff takes the stack entry id number as " \
                       "an argument (top-most is 0), but found '$1'"
        elif (( $# > 1 ))
        then
            UsageError "$command" "Too many arguments"
        fi
        args+=("stash@{$1}")
    fi

    OUTA=("${args[@]}")
}

function gh_stack_diff {
    ParseStackElementId "$@"
    RunOrFail git stash show -u "${OUTA[@]}"
}

function gh_stack_drop {
    ParseStackElementId "$@"
    RunOrFail git stash drop "${OUTA[@]}"
}

function gh_stack_list {
    RunOrFail git stash list
}

function gh_stack_showall {
    local -i num
    git stash list | while read -r; do num+=1; done

    local -i i=0
    for ((i=0; i<num; ++i))
    do
        echo "$i: # Stack element ID"
        # Apparently, untracked files are stored in stash@{0}^3,
        # but without untracked files there is no such commit.
        echo "Warning: untracked files are not shown"
        git stash show "$i"
    done
}

function gh_stack_pop {
    ParseStackElementId "$@"
    # <"${OUTA[@]"> could expand to <2>, which would mean stash id 2 would be
    # popped.  Default is <0>.
    
    if ! OUT=$(git stash pop "${OUTA[@]}" 2>&1) && test "$OUT" != "No stash entries found."
    then
        echo "$OUT" >&2
        false
    elif test -n "$OUT"
    then
        echo "$OUT"
    fi
}

function gh_stack_push {
    local -a args=()

    while (( $# > 0 ))
    do
        case "$1" in
            -H|--hunk)
                args+=(-p)
                shift
                ;;
            -m|--message)
                args+=(-m "$2")
                shift 2 || true
                ;;
            -*)
                Fail "Unknown option '$1'"
                ;;
            *) break ;;
        esac
    done

    RunOrFail git reset -q HEAD
    RunOrFail git stash push -u "${args[@]}" -- "$@"
    Stage
}

function gh_stack_show {
    ParseStackElementId "$@"
    RunOrFail git stash show "${OUTA[@]}"
}

function gh_status {
    Stage
    Run git status --short
}

function gh_submit {
    local wait=true open_chrome=true
    while (( $# > 0 ))
    do
        case "$1" in
            -W) wait=false; shift ;;
            -o) open_chrome=true; shift ;;
            -*) UsageError submit "Unknown option: '$1'" ;;
            *) break ;;
        esac
    done

    if (( $# != 1 ))
    then
        UsageError submit "Missing TITLE argument"
    fi
    local title="$1"

    if ! IsClean
    then
        UsageError submit "Files have been changed since last commit"
    fi

    GetBranch
    local branch="$OUT"

    if test "$branch" == master
    then
        UsageError submit "Cannot submit master branch"
    fi

    GitHubInfoFromOrigin
    local endpoint="$OUT"
    local owner="$OUT2"
    local repo="$OUT3"
    local ssh_url="$OUT4"

    if GetPullRequestNumber "$endpoint" "$owner" "$repo" "$branch"
    then
        local number="$OUT"
        local url="$OUT2"
        UsageError submit "A pull request has already been made: $url"
    fi

    git push -q -u origin "$branch"

    CreatePullRequest "$endpoint" "$owner" "$repo" "$branch" "$title"
    local number="$OUT"
    local url="$OUT2"
    echo "Created pull request $url"

    if $open_chrome
    then
        google-chrome "$url"
    fi

    if $wait
    then
        local approve=false assignee= merge=false ptal=false reviewers=

        WaitForChecksThen "$endpoint" "$owner" "$repo" "$number" \
                          "$approve" "" "$assignee" "$merge" "$ptal" \
                          "$reviewers"
    fi
}

function GetGitRootRelative {
    local out
    if ! out=$(git rev-parse --show-cdup 2>&1)
    then
        Fail "Not in a git repository? 'git rev-parse --show-cdup' failed: $out"
    fi

    # If PWD is in root, out is empty.
    local root="${out%/}"
    if ((${#root} == 0))
    then
        root=.
    fi

    if ! [ -d "$root" ]
    then
        Fail "Failed to find root, '$root' not a directory"
    fi

    OUT="$root"
}

function Stage {
    GetGitRootRelative
    local root="$OUT"

    local -a root_args=()
    if [ "$root" == . ]
    then
        # TODO: Shouldn't this be (.) ?
        root_args=()
    elif [[ "$root" =~ ^- ]]
    then
        root_args=(-- "$root")
    else
        root_args=("$root")
    fi

    Run git reset --quiet "${root_args[@]}"
    Run git add --all "${root_args[@]}"
}

function IsClean {
    CaptureStd git status --short
    if test "$OUT" == ""
    then
        return 0
    else
        return 1
    fi
}

function GetPullRequestNumber {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local branch="$4"

    ToJsonString "$owner"
    local owner_json="$OUT"
    ToJsonString "$repo"
    local repo_json="$OUT"
    ToJsonString "$branch"
    local branch_json="$OUT"

    local query="
query {
  repository(owner:$owner_json name: $repo_json) {
    pullRequests(first:1 headRefName: $branch_json) {
      pageInfo {
        hasNextPage
      }
      nodes {
        number
        url
      }
    }
  }
}"
    
    QueryGraph "$endpoint" "$query"
    local json="$OUT"

    JqRaw ".data.repository.pullRequests.pageInfo.hasNextPage" "$json"
    case "$OUT" in
        false) : ;;
        true) Fail "More than one pull requests are open for current branch" ;;
        *) Fail "Failed to get pull request list: '$json'" ;;
    esac

    Jq ".data.repository.pullRequests.nodes | length" "$json"
    case "$OUT" in
        0) return 1 ;;
        1) : ;;
        *) Fail "Failed to get pull request list: '$json'" ;;
    esac

    JqRaw ".data.repository.pullRequests.nodes[].number" "$json"
    local number="$OUT"

    if test "$number" == ""
    then
        return 1
    elif ! [[ "$number" =~ ^[0-9]+$ ]]
    then
        Fail "Failed to get pull request number: '$json'"
    fi

    JqRaw ".data.repository.pullRequests.nodes[].url" "$json"
    local url="$OUT"

    if ! [[ "$url" =~ ^http ]]
    then
        Fail "Failed to get pull request URL: '$json'"
    fi

    OUT="$number"
    OUT2="$url"
}

function RawCreatePullRequest {
    local destination="$1"
    local owner="$2"
    local repo="$3"
    ToJsonString "$4"
    local branch_to_review="$OUT"
    ToJsonString "$5"
    local merge_branch="$OUT"
    ToJsonString "$6"
    local title="$OUT"
    ToJsonString "$7"
    local body="$OUT"

    local data="{
  \"head\": $branch_to_review,
  \"base\": $merge_branch,
  \"title\": $title,
  \"body\": $body
}"

    PostRest "$endpoint" "/repos/$owner/$repo/pulls" -d "$data"
    local json="$OUT"

    Jq .number "$json"
    local number="$OUT"

    JqRaw .html_url "$json"
    local url="$OUT"

    OUT="$number"
    OUT2="$url"
}

function CreatePullRequest {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local branch="$4"
    local title="$5"  # Optional

    local destination_branch="master"

    local body=
    if test "$title" == ""
    then
        # TODO: If more than 1 commit ahead of origin/master, we should open an
        # editor to specify title and body.

        title=$(git log -1 --format=%s HEAD)

        body=$(git log -1 --format=%b HEAD)
        if [[ "$body" =~ ^[' '$'\n'$'\r']+$ ]]
        then
            body=""
        fi
    fi

    RawCreatePullRequest "$destination" "$owner" "$repo" "$branch" \
                         "$destination_branch" "$title" "$body"
    # Pass through output variables
}

function gh_help_checkin {
    cat <<EOF
Usage: gh checkin [OPTION...] [MESSAGE]
Commit with MESSAGE and a branch derived from MESSAGE, and push to remote.

Options:
  --                       Any next argument is interpreted as MESSAGE.
  --assignee,-a ASSIGNEE   Assign pull request to ASSIGNEE.
  --comment,-c COMMENT     Use MESSAGE for branch name, and COMMENT for commit.
  --edit,-e                Edit the commit message (MESSAGE) before committing.
  --merge,-m               Merge once all pull request checks pass.
  --ptal,-p                Add a PTAL message to the pull request.
  --reviewers,-r REVS      Set the pull request reviewers to REVS, once the
                           pull request checks pass.
EOF
    exit 0
}

function gh_checkin {
    local assignee="" merge=false ptal=false title="" open_google_chrome=false
    local escaped_edit_option= reviewers="" wait=true comment=
    while (( $# > 0 ))
    do
        case "$1" in
            --)
                shift
                break
                ;;
            -a|--assignee)
                assignee="$2"
                shift 2
                ;;
            -c|--comment)
                comment="$2"
                shift 2
                ;;
            -e|--edit)
                escaped_edit_option=--edit
                shift
                ;;
            -h|--help) gh_help checkin ;;
            -m|--merge)
                merge=true
                shift
                ;;
            -o|--open)
                open_google_chrome=true
                shift
                ;;
            -p|--ptal)
                ptal=true
                shift
                ;;
            -r|--reviewers)
                reviewers="$2"
                shift 2
                ;;
            -w|--no-wait)
                wait=false
                shift
                ;;
            -*) UsageError checkin "Unknown option '$1'" ;;
            *) break ;;
        esac
    done

    GitHubInfoFromOrigin
    local endpoint="$OUT"
    local owner="$OUT2"
    local repo="$OUT3"
    local ssh_url="$OUT4"

    # This check has to be done before any mutable operations: the below branch
    # creation.
    if test "$assignee" != ""
    then
        LookupAssignee "$endpoint" "$owner" "$repo" "$assignee"
        assignee="$OUT"
    fi

    # This check has to be done before any mutable operations: the below branch
    # creation.
    if test "$reviewers" != ""
    then
        LookupReviewers "$endpoint" "$owner" "$repo" "$reviewers"
        reviewers="$OUT"
    fi

    local known_to_be_dirty=false

    GetBranch
    local branch="$OUT"

    if test "$branch" == master
    then
        if IsClean
        then
            Fail "On master branch, and there's nothing to commit"
        fi
        known_to_be_dirty=true

        if (( $# != 1 ))
        then
            UsageError checkin "Missing TITLE argument"
        fi
        local title="$1"

        branch="${title,,}"
        branch=$(printf "%s" "$branch" | tr ' ' - | tr -Cd '[:alnum:]-')
        if test "$branch" == ""
        then
            Fail "Failed to find a good branch name from the title '$title'"
        fi

        if test "$comment" == ""
        then
            local message="$title"
        else
            local message="$comment"
        fi

        ResolveEndpoint "$endpoint"
        local user="$OUT2"

        if test "$owner" == vespa -a "$repo" == vespa-yahoo
        then
            # HACK: Special code invoked when branch are identical, so force
            # one user.  Don't merge this gh version...
            user=hakonhall
        fi

        branch="$user/$branch"

        Stage
        git stash save --quiet --include-untracked
        if ! git checkout --quiet -b "$branch"
        then
            echo "Error checking out new branch!"
            echo "To retrieve your work, issue 'git stash pop'"
            exit 1
        fi
        git stash pop --quiet

        Stage
        git commit --quiet $escaped_edit_option -m "$message"
    elif ! IsClean
    then
        local -a args=()
        case "$#" in
            0) : ;;
            1) args+=(-m "$1") ;;
            *) UsageError checkin "Too many arguments" ;;
        esac

        Stage
        git commit --quiet $escaped_edit_option "${args[@]}"
    elif (( $# != 0 ))
    then
        UsageError checkin "Too many arguments: No local changes but " \
                   "TITLE given"
    fi
    
    git push -q -u origin "$branch"

    if GetPullRequestNumber "$endpoint" "$owner" "$repo" "$branch"
    then
        local number="$OUT"
        local url="$OUT2"
        echo "Found pull request $url"
    else
        CreatePullRequest "$endpoint" "$owner" "$repo" "$branch"
        local number="$OUT"
        local url="$OUT2"
        echo "Created pull request $url"
    fi

    if $open_google_chrome
    then
        google-chrome "$url"
    fi

    if $wait
    then
        local approve=false

        WaitForChecksThen "$endpoint" "$owner" "$repo" "$number" \
                          "$approve" "" "$assignee" "$merge" "$ptal" \
                          "$reviewers"
    fi
}

function gh_uncommit {
    if (( $# > 0 ))
    then
        UsageError uncommit "Command takes exactly zero arguments"
    fi

    git reset --soft HEAD^
    Stage

    # To undo the last commit on a branch you own on github:
    # Say C is the commit hash of current HEAD, and B is the branch.
    #   git push origin +C^:B
    # Alternatively, if B is checked out locally:
    #   git reset HEAD^ --hard
    #   git push origin -f
    # The first command would also be 'gh uncommit; gh revert'
}

function gh_clean_branch {
    CaptureStdLines git branch
    local -a lines=("${OUTA[@]}")

    local line
    for line in "${lines[@]}"
    do
        if ! [[ "$line" =~ ^('* '|'  ')([^' ']+) ]]
        then
            Fail "Unexpected format for line output by 'git branch': '$line'"
        fi

        local branch="${BASH_REMATCH[2]}"
        if test "${BASH_REMATCH[1]}" == '  '
        then
            if ! git branch --quiet -d "$branch" &> /dev/null
            then
                if ! read -n1 -p "Force-delete '$branch'? [Y/n] "
                then
                    echo
                    Fail "Failed to read answer"
                fi

                case "$REPLY" in
                    "") : ;;
                    y|Y) echo ;;
                    *)
                        echo
                        continue
                        ;;
                esac

                if ! git branch --quiet -D "$branch"
                then
                    # There should already be some error messages printed
                    Fail "Aborting"
                fi
            fi

            echo "Removed '$branch'"
        fi
    done
}

function gh_branch {
    local clean=false
    local full=false # Qualify the branch name with the repo ID

    while (( $# > 0 ))
    do
        case "$1" in
            --clean) clean=true ;;
            -f|--full) full=true ;;
            *) break ;;
        esac
        shift
    done

    if (( $# > 0 ))
    then
        UsageError branch "Too many arguments"
    fi

    if $clean
    then
        if gh_clean_branch
        then
            return 0
        else
            return $?
        fi
    fi

    GetBranch
    local branch="$OUT"

    if $full
    then
        GitHubInfoFromOrigin
        local endpoint="$OUT"
        local owner="$OUT2"
        local repo="$OUT3"
        local ssh_url="$OUT4"

        branch="$endpoint:$owner/$repo#$branch"
    fi
    
    echo "$branch"
}

function GetRepoId {
    GitHubInfoFromOrigin
    local endpoint="$OUT"
    local owner="$OUT2"
    local repo="$OUT3"
    local ssh_url="$OUT4"

    OUT="$endpoint:$owner/$repo"
}

function gh_repo {
    GetRepoId
    echo "$OUT"
}

function gh_checkout {
    if (( $# != 1 ))
    then
        UsageError checkout "Command takes exactly one argument"
    fi
    local branch_or_pr_number_or_pr_url="$1"

    local need_to_pop=false
    if ! IsClean
    then
        git stash save --quiet
        need_to_pop=true
    fi

    local pending_error_message=
    if ! git checkout --quiet "$branch_or_pr_number_or_pr_url" 2> /dev/null
    then
        if PullRequestInfo "$branch_or_pr_number_or_pr_url"
        then
            pr_endpoint="$OUT"
            pr_owner="$OUT2"
            pr_repo="$OUT3"
            pr_branch="$OUT4"
            pr_number="$OUT5"

            GitHubInfoFromOrigin
            local current_endpoint="$OUT"
            local current_owner="$OUT2"
            local current_repo="$OUT3"

            if test "$pr_endpoint" == "$current_endpoint" && \
                    test "$pr_owner" == "$current_owner" && \
                    test "$pr_repo" == "$current_repo"
            then
                # The pull request may exist on origin but may not yet have
                # been pulled.
                # TODO: Verify upstream is origin.
                git fetch -q origin

                echo "Checking out branch $pr_branch"
                if ! git checkout -q "$pr_branch"
                then
                    pending_error_message="Failed to check out '$pr_branch'"
                fi
            else
                pending_error_message="Pull request '$branch_or_pr_number_or_pr_url' refers to a different repository"
            fi
        else
            pending_error_message="'$branch_or_pr_number_or_pr_url' is neither a branch, PR number, or PR URL"
        fi
    fi

    if test -n "$pending_error_message"
    then
        if $need_to_pop
        then
            pending_error_message+=$'\n'"Your local changes have been stashed"
        fi
        Fail "$pending_error_message"
    fi

    if $need_to_pop
    then
        git stash pop --quiet
    fi
}

function gh_commit {
    Stage
    local -a edit_option=()
    while (( $# > 0 ))
    do
        case "$1" in
            -e|--edit) edit_option=(-e); shift ;;
            *) break ;;
        esac
    done

    if (( $# == 0 ))
    then
        UsageError "Missing commit message"
    fi
    git commit "${edit_option[@]}" -m "$1"
}

function gh_clean {
    # g_delete_branches
    Run git reset --hard
    # -f:  Force
    # -d:  Remove directories
    # -x:  Don't read .gitignore and GIT_DIR/info/exclude
    Run git clean -fdx
}

function gh_update {
    if (( $# != 0 ))
    then
        UsageError update "Command takes exactly zero arguments"
    fi

    GetBranch
    local branch="$OUT"

    PendingUpstreamCommits "$branch"
    local upstream="$OUT"

    CaptureStd git rev-parse "$branch"
    local branch_commit="$OUT"

    CaptureStd git rev-parse "$upstream"
    local upstream_commit="$OUT"

    if test "$upstream_commit" == "$branch_commit"
    then
        # There are no upstream changes
        echo "There were no upstream changes"
        return
    fi

    CaptureStd git stash --include-untracked
    local stash_output="$OUT"

    git rebase -q "$upstream"

    if ! [[ "$stash_output" =~ ^'No local changes to save'$ ]]
    then
        # Cannot be --quiet, since it swallows warnings about conflicts.
        RunOrFail git stash pop
    fi
}

function gh_diff {
    Stage

    if [[ -t 1 && ( -v DISPLAY || $MACHTYPE =~ -apple-darwin ) ]] &&
           diffuse -h 2> /dev/null | grep -q -- --modified-since &&
           false # diffuse fails to import gtk on my machine, but -h still works
    then
        local modified_since=HEAD

        while (( $# > 0 ))
        do
            case "$1" in
                -m|--merge-base)
                    modified_since=$(git merge-base origin/master HEAD)
                    ;;
                -c|--commit)
                    modified_since="$2"
                    shift
                    ;;
                -*) Fail "Unknown option '$1'" ;;
                *) Fail "Unknown subcommand '$1'" ;;
            esac
            shift
        done

        if git diff --quiet --cached "$modified_since"
        then
            echo "There are no changes since $modified_since"
        else
            MaybeEchoCommand diffuse -M "$modified_since"
            # diffuse outputs warning:
            #   *** WARNING: Method userSpaceScaleFactor in class NSView...
            # Which is not even invoked by diffuse.
            exec diffuse -M "$modified_since" 2> /dev/null &
            echo "diffuse spawned in the background"
        fi

        return 0
    fi

    local branches=()
    if test "$1" == -m || test "$1" == --merge-base
    then
        shift
        local merge_base=$(git merge-base origin/master HEAD)
        branches+=("$merge_base")
    else
        branches+=(HEAD)
    fi
    git diff "$@" "${branches[@]}"
}

function gh_head {
    gh_checkout master
    gh_update
}

function gh_history {
    Stage
    if type gitk &> /dev/null
    then
        gitk
    else
        git log
    fi
}

function TryGetPullRequest {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    
    ToJsonString "$owner"
    local owner_json="$OUT"

    ToJsonString "$repo"
    local repo_json="$OUT"

    ResolveEndpoint "$endpoint"

    local query="query {
  repository(owner:$owner_json name:$repo_json) {
    pullRequest(number:$number) {
      assignees(first:100) {
        nodes {
          login
        }
      }
      reviewRequests(first:100) {
        nodes {
          requestedReviewer {
            ...on User {
              login
            }
          }
        }
      }
      reviews(first:100) {
        nodes {
          author {
            ...on User {
              login
            }
          }
        }
      }
      comments(last:1) {
        pageInfo {
          endCursor
        }
      }
      headRef {
        name
        target {
          oid
        }
      }
      mergeable
      merged
      state
      url
    }
  }
}"

    QueryGraph "$endpoint" "$query"
    local json="$OUT"

    Jq ".data.repository.pullRequest" "$json"
    if test "$OUT" == null
    then
        return 1
    fi
    json="$OUT"

    JqRaw ".state" "$json"
    local state="$OUT"
    case "$state" in
        OPEN) : ;;
        CLOSED|MERGED)
            # E.g. the head commit is not available if closed, which we return
            # below (may not be needed?), therefore bail out here.
            Fail "Pull request is $state"
            ;;
        *) Fail "Pull request in bad state '$state'" ;;
    esac

    JqRaw ".headRef.name" "$json"
    local branch="$OUT"
    if ! [[ "$branch" =~ ^[a-zA-Z0-9_/.-]+$ ]]
    then
        Fail "Unexpected name of branch: '$branch'"
    elif test "$branch" == master
    then
        Fail "Pull request bound to master, refusing to proceed"
    fi

    JqRaw ".headRef.target.oid" "$json"
    local head_commit="$OUT"
    if ! [[ "$head_commit" =~ ^[a-f0-9]{40}$ ]]
    then
        Fail "Unexpected format of head commit: '$head_commit'"
    fi

    JqRaw ".url" "$json"
    local url="$OUT"
    if ! [[ "$url" =~ ^http ]]
    then
        Fail "Unexpected format of pull request URL: '$url'"
    fi

    Jq ".comments" "$json"
    local last_comments_id="$OUT"
    if test "$last_comments_id" != null
    then
        JqRaw ".comments.pageInfo.endCursor" "$json"
        last_comment_id="$OUT"
    fi

    JqRawLines ".assignees.nodes[].login" "$json"
    local -a assignees=("${OUTA[@]}")

    # A reviewer that has added a comment is in reviews, otherwise in
    # reviewRequests.
    JqRawLines ".reviewRequests.nodes[].requestedReviewer.login" "$json"
    local -a reviewers=("${OUTA[@]}")
    JqRawLines ".reviews.nodes[].author.login" "$json"
    reviewers+=("${OUTA[@]}")

    OUT="$branch"
    OUT2="$head_commit"
    OUT3="$url"
    OUT4="$last_comment_id"
    OUTA=("${assignees[@]}")
    OUTA2=("${reviewers[@]}")
}

function GetPullRequest {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"

    if ! TryGetPullRequest "$@"
    then
        Fail "There is no pull request $number at $endpoint:$owner/$repo"
    fi
}

function FindEndpointIfPullRequestUrl {
    local url="$1"

    # Example: https://github.com/vespa-engine/vespa/pull/3937#ignored
    if ! [[ "$url" =~ ^https://([a-zA-Z0-9.-]+)(/[^?#]+)?/([^/]+)/([^/]+)/pull/([0-9]+)(\#.*)?$ ]]
    then
        return 1
    fi

    # Remove any suffix #foo
    local sub_url="${url%${BASH_REMATCH[6]}}"

    local authority="${BASH_REMATCH[1]}"
    local owner="${BASH_REMATCH[3]}"
    local repo="${BASH_REMATCH[4]}"
    local number="${BASH_REMATCH[5]}"

    ToJsonString "$owner"
    local owner_json="$OUT"

    ToJsonString "$repo"
    local repo_json="$OUT"

    local query="query {
  repository(owner:$owner_json name:$repo_json) {
    pullRequest(number:$number) {
      url
    }
  }
}"

    GetEndpoints
    local -a endpoints=("${OUTA[@]}")
    
    local endpoint
    for endpoint in "${endpoints[@]}"
    do
        if TryGetPullRequest "$endpoint" "$owner" "$repo" "$number"
        then
            local branch="$OUT"
            local canonical_url="$OUT3"
            local -a assignees=("${OUTA[@]}")
            local -a reviewers=("${OUTA2[@]}")

            if test "$sub_url" != "$canonical_url"
            then
                Fail "URL '$url' does not match pull request url " \
                     "'$canonical_url'"
            fi

            OUT="$endpoint"
            OUT2="$owner"
            OUT3="$repo"
            OUT4="$number"
            OUT5="$branch"
            OUTA=("${assignees[@]}")
            OUTA2=("${reviewers[@]}")
            return 0
        fi
    done

    Fail "No endpoint in config file '$CONFIG_FILE' owns '$url'"
}

function ChecksAt {
    local json="$1"
    shift
    local -a fields=("$@")

    if ! Jq ".checks" "$json"
    then
        Fail "Failed to access .checks of '$json'"
    fi
    local checks_json="$OUT"

    if test "$checks_json" == null
    then
        local has_checks=false
        local -a checks=()
    else
        local has_checks=true
        JqRawLines ".checks[]" "$json"
        local -a checks=("${OUTA[@]}")
    fi

    local has_field_value=true

    local field
    for field in "${fields[@]}"
    do
        ToJsonString "$field"
        local field_json="$OUT"

        if ! Jq ".$field_json" "$json"
        then
            Fail "Failed to access '$field_json' of '$json'"
        fi
        json="$OUT"

        if test "$json" == null
        then
            has_field_value=false
            break
        else
            has_field_value=true
        fi
    done

    OUT="$has_checks"
    OUT2="$has_field_value"
    OUT3="$json"
    OUTA=("${checks[@]}")
}

function GetChecksFor {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"

    ReadConfigAsString
    local json="$OUT"

    local -a root_fields=(endpoints "$endpoint")
    local -a endpoint_fields=(owners "$owner")
    local -a owner_fields=(repos "$repo")
    local -a repo_fields=()

    local -a checks=()

    local field
    for field in root endpoint owner repo
    do
        local -n fields="${field}_fields"

        ChecksAt "$json" "${fields[@]}"
        local has_checks="$OUT"
        if $has_checks
        then
            checks=("${OUTA[@]}")
        fi

        local has_field_value="$OUT2"
        if $has_field_value
        then
            json="$OUT3"
        else
            break
        fi

        # Without this, the next iteration of the loop will think we're setting
        # the -n (nameref) attribute on endpoint_fields (and warn that -n
        # cannot be set on an array).
        unset -n fields
done

    OUTA=("${checks[@]}")
}

function CheckStatus {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    local commit="$5"
    local last_comment_id="$6"

    ToJsonString "$owner"
    local owner_json="$OUT"

    ToJsonString "$repo"
    local repo_json="$OUT"

    local query="query {
  repository(owner:$owner_json name:$repo_json) {
    pullRequest(number:$number) {
      comments(last:1) {
        pageInfo {
          endCursor
        }
      }
      state
      merged
      mergeable
      headRef {
        name
      }
      commits(last: 1) {
        nodes {
          commit {
            oid
            status {
              state
              contexts {
                context
                description
                state
                targetUrl
              }
            }
          }
        }
      }
    }
  }
}"

    QueryGraph "$endpoint" "$query"
    local json="$OUT"

    Jq ".data.repository.pullRequest" "$json"
    json="$OUT"

    JqRaw ".state" "$json"
    local state="$OUT"

    case "$state" in
        OPEN) : ;;
        null)
            OUT="The state of the pull request is not yet known"
            return 1
            ;;
        *) Fail "State is not OPEN: '$state'" ;;
    esac

    JqRaw ".merged" "$json"
    local merged="$OUT"

    case "$merged" in
        false) : ;;
        null)
            OUT="Checking whether pull request has been merged"
            return 1
            ;;
        true) Fail "Pull request has been merged" ;;
        *) Fail "Unknown merged status '$merged'" ;;
    esac

    JqRaw ".mergeable" "$json"
    local mergeable="$OUT"

    case "$mergeable" in
        MERGEABLE) : ;;
        CONFLICTING)
            Fail "Pull requests is conflicting with origin/master"
            ;;
        null|UNKNOWN)
            OUT="Checking for ability to automatically merge"
            return 1
            ;;
        *) Fail "Unknown mergeable status '$mergeable'" ;;
    esac

    JqRaw ".headRef.name" "$json"
    local branch="$OUT"

    Jq ".comments" "$json"
    local current_last_comment_id="$OUT"
    if test "$current_last_comments_id" != null
    then
        JqRaw ".comments.pageInfo.endCursor" "$json"
        current_last_comment_id="$OUT"
    fi
    if test "$current_last_comment_id" != "$last_comment_id"
    then
        Fail "Comments have been added, aborting status check"
    fi

    Jq ".commits.nodes[].commit" "$json"
    json="$OUT"

    Jq ".status" "$json"
    local status="$OUT"
    if test "$status" == "null"
    then
        local -a checks=()
    else
        JqRawLines ".status.contexts[].context" "$json"
        local -a checks=("${OUTA[@]}")
    fi

    GetChecksFor "$endpoint" "$owner" "$repo"
    local -a required_checks=("${OUTA[@]}")

    local required_check=""
    for required_check in "${required_checks[@]}"
    do
        local check_passes=false

        local check=""
        for check in "${checks[@]}"
        do
            if [[ "$check" =~ $required_check ]]
            then
                ToJsonString "$check"
                local check_json="$OUT"

                JqRaw ".status.contexts[] | select(.context == $check_json)" \
                      "$json"
                local context_json="$OUT"

                JqRaw ".state" "$context_json"
                local context_state="$OUT"

                JqRaw ".description" "$context_json"
                local description="$OUT"

                JqRaw ".targetUrl" "$context_json"
                local target_url="$OUT"

                case "$context_state" in
                    SUCCESS) : ;;
                    null|PENDING)
                        OUT="Check not finished: $description"$'\n'
                        OUT+="See $target_url for details"
                        return 1
                        ;;
                    *) Fail "Bad check status: '$context_state'"
                esac

                check_passes=true
                break
            fi
        done

        if ! $check_passes
        then
            OUT="Waiting for check matching '$required_check'"
            return 1
        fi
    done

    JqRaw ".status.state" "$json"
    local status_state="$OUT"

    case "$status_state" in
        SUCCESS) : ;;
        null|PENDING)
            # If there are no required checks, status may be null.
            if (( ${#required_checks[@]} > 0 ))
            then
                OUT="Overall status not yet determined"
                return 1
            fi
            ;;
        *) Fail "Bad overall check state: '$status_state'" ;;
    esac

    JqRaw ".oid" "$json"
    local head_commit="$OUT"

    if test "$head_commit" != "$commit"
    then
        Fail "Additional commits have been added, refusing to continue"
    fi
}

function WaitForChecks {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    local commit="$5"
    local last_comment_id="$6"

    local -i sleep_seconds=1
    local pending_message=""
    local previous_message="foo"
    while ! CheckStatus "$endpoint" "$owner" "$repo" "$number" "$commit" \
            "$last_comment_id"
    do
        local message="$OUT"
        if test "$message" == ""
        then
            Fail "Internal error: Check status failed but without message"
        fi

        if test "$message" != "$previous_message"
        then
            printf "%s%s..." "$pending_message" "$message"
            pending_message=$'\n'
            sleep_seconds=1
        else
            printf "."

            if (( sleep_seconds < 10 ))
            then
                sleep_seconds+=1
            fi
        fi

        previous_message="$message"
        sleep "$sleep_seconds"
    done

    printf "%s%s\n" "$pending_message" "All checks pass"
}

function AssignPullRequest {
    endpoint="$1"
    owner="$2"
    repo="$3"
    number="$4"
    assignee="$5"

    ToJsonString "$assignee"
    local assignee_json="$OUT"
    local data="{\"assignees\": [ $assignee_json ]}"

    local path="/repos/$owner/$repo/issues/$number/assignees"
    PostRest "$endpoint" "$path" -d "$data"

    # Unfortunately, even if assignee is bogus, the POST returns 201 OK.  The
    # assignee list will not be updated, so the only way to check is if
    # assignee is in $out, or do an explicit check on whether assignee is
    # assigned. We'll just assume it's OK. But we also verify the assignee is
    # valid before the POST.
}

function AddPullRequestComment {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    local comment="$5"

    ToJsonString "$comment"
    local comment_json="$OUT"
    local data="{\"body\": $comment_json }"

    local path="/repos/$owner/$repo/issues/$number/comments"
    PostRest "$endpoint" "$path" -d "$data"
}

function Ptal {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    shift 4
    local -a assignees=("$@")

    if (( ${#assignees[@]} == 0 ))
    then
        Fail "There are no assignees to ask for PTAL"
    fi

    local comment="Please take another look"
    local assignee
    for assignee in "${assignees[@]}"
    do
        comment+=" @$assignee"
    done

    AddPullRequestComment "$endpoint" "$owner" "$repo" "$number" "$comment"
}

function ApprovePullRequest {
    endpoint="$1"
    owner="$2"
    repo="$3"
    number="$4"
    commit="$5"

    local data="{\"commit_id\": \"$commit\", \"event\": \"APPROVE\"}"
    PostRest "$endpoint" "/repos/$owner/$repo/pulls/$number/reviews" -d "$data"
}

function GetMergeMethod {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"

    ReadConfigAsString
    local json="$OUT"

    ToJsonString "$endpoint"
    local eJson="$OUT"
    ToJsonString "$owner"
    local oJson="$OUT"
    ToJsonString "$repo"
    local rJson="$OUT"

    JqRaw ".endpoints.$eJson.owners.$oJson.repos.$rJson.merge_method" "$json"
    local merge_method="$OUT"

    if test "$merge_method" == null
    then
        # Default merge method
        merge_method=merge
    fi

    OUT="$merge_method"
}

function MergePullRequest {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    local commit="$5"

    if ! [[ "$number" =~ ^[0-9]+$ ]]
    then
        Fail "Bad PR number: '$pr_number'"
    elif ! [[ "$commit" =~ ^[0-9a-f]{40}$ ]]
    then
        Fail "Bad HEAD commit: '$commit'"
    fi

    GetMergeMethod "$endpoint" "$owner" "$repo"
    ToJsonString "$OUT"
    local merge_method="$OUT"

    PutRest "$endpoint" "/repos/$owner/$repo/pulls/$number/merge" \
            -d "{ \"sha\": \"$commit\", \"merge_method\": $merge_method }"
}

function LookupReviewers {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local reviewers="$4"

    SplitBy "$reviewers" ,
    local -a reviewers_array=("${OUTA[@]}")

    reviewers=""

    local reviewer
    for reviewer in "${reviewers_array[@]}"
    do
        LookupReviewer "$endpoint" "$owner" "$repo" "$reviewer"

        if test -z "$reviewers"
        then
            reviewers="$OUT"
        else
            reviewers+=,"$OUT"
        fi
    done

    OUT="$reviewers"
}

function WaitForChecksThen {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"

    local approve="$5"
    local comment="$6"
    local assignee="$7" # Possibly bad
    local merge="$8"
    local ptal="$9"
    local reviewers_string="${10}" # Possibly bad

    if test "$assignee" != ""
    then
        LookupAssignee "$endpoint" "$owner" "$repo" "$assignee"
        assignee="$OUT"
    fi

    if test "$reviewers_string" != ""
    then
        LookupReviewers "$endpoint" "$owner" "$repo" "$reviewers_string"
        reviewers_string="$OUT"
    fi

    GetPullRequest "$endpoint" "$owner" "$repo" "$number"
    local branch="$OUT"
    local commit="$OUT2"
    local last_comment_id="$OUT4"
    local -a assignees=("${OUTA[@]}")
    local -a current_reviewers=("${OUTA2[@]}")

    WaitForChecks "$endpoint" "$owner" "$repo" "$number" "$commit" \
                  "$last_comment_id"

    if test "$assignee" != ""
    then
        AssignPullRequest "$endpoint" "$owner" "$repo" "$number" "$assignee"
        echo "$assignee assigned to PR"
    fi

    if test "$reviewers_string" != ""
    then
        AddReviewers "$endpoint" "$owner" "$repo" "$number" "$reviewers_string"
    fi

    if test "$comment" != ""
    then
        AddPullRequestComment "$endpoint" "$owner" "$repo" "$number" "$comment"
    fi

    if $ptal
    then
        ResolveEndpoint "$endpoint"
        local user="$OUT2"

        local -A ptal_logins=()
        local login
        for login in "${assignees[@]}" "${current_reviewers[@]}"
        do
            if test "$login" != "$user"
            then
                ptal_logins["$login"]=1
            fi
        done

        if (( ${#ptal_logins[@]} == 0 ))
        then
            UsageError wait "There are no reviewers to ask for PTAL from"
        fi

        # Printing happens in function
        Ptal "$endpoint" "$owner" "$repo" "$number" "${!ptal_logins[@]}"
        echo "Asked for PTAL from: ${!ptal_logins[*]}"
    fi

    if $approve
    then
        ApprovePullRequest "$endpoint" "$owner" "$repo" "$number" "$commit"
        echo "Pull request approved"
    fi

    if $merge
    then
        MergePullRequest "$endpoint" "$owner" "$repo" "$number" "$commit"
        echo "Pull request merged"

        # Auto-delete branch may have been enabled, in case this will fail with
        # message:

        #   error: unable to delete 'hakonhall/add-gitignore': remote ref does not exist
        #   error: failed to push some refs to 'git@github.com:hakonhall/gh.git'"
        local output
        if output=$(git push --quiet --delete origin "$branch" 2>&1)
        then
            test "$output" == "" || printf "%s\n" "$output"
        elif ! [[ "$output" == *'remote ref does not exist'* ]]
        then
            printf "%s\n" "$output" >&2
            return 1
        fi

        GetBranch
        local wd_branch="$OUT"

        if test "$wd_branch" == "$branch"
        then
            if ! git checkout --quiet master
            then
                Fail "Failed to check out master"
            fi

            if ! git pull --quiet --rebase
            then
                Fail "Failed to pull master"
            fi

            echo "master checked out and updated"

            # The following git command may output the following warning, if
            # the repo has been set up to a merge method other than 'merge':
            #
            # warning: deleting branch 'hakonhall/add-gitignore' that has been merged to
            #          'refs/remotes/origin/hakonhall/add-gitignore', but not yet merged to HEAD.
            if ! git branch --quiet -d "$wd_branch"
            then
                Fail "Failed to delete local branch '$wd_branch'"
            fi

            echo "Deleted local branch '$wd_branch'"
        fi
    fi

    echo Success
}

function GetMentionableUsers {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"

    ToJsonString "$owner"
    local owner_json="$OUT"

    ToJsonString "$repo"
    local repo_json="$OUT"

    local query_prefix="query {
  repository(owner:$owner_json name:$repo_json) {
    mentionableUsers(first:100"

    local query_suffix=") {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        login
        name
      }
    }
  }
}"

    QueryGraphList "$endpoint" "$query_prefix" "$query_suffix" \
                   ".data.repository.mentionableUsers"
    local mentionable_users="$OUT"

    # mentionable_users='{"login":"x1","name":"y1 z1"}
    # {"login":"x2","name":"y2 z2"}
    # ...
    # '
    OUT="$mentionable_users"
}

function LookupAssignee {
    LookupLogin assignee "$@"
}

function LookupReviewer {
    LookupLogin reviewer "$@"
}

function LookupLogin {
    local description="$1" # e.g. reviewer or assignee
    shift
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local name_or_login="$4"

    if test "$name_or_login" == ""
    then
        Fail "${description^} cannot be empty"
    fi

    GetMentionableUsers "$endpoint" "$owner" "$repo"
    local users_arrayish="$OUT"

    ToJsonString "$name_or_login"
    local name_or_login_json="$OUT"

    JqRawLines "select(.login == $name_or_login_json) | .login" \
               "$users_arrayish"
    local -a matches=("${OUTA[@]}")

    case "${#matches[@]}" in
        0)
            Jq "select(.name != null) | select(.name | test($name_or_login_json; \"i\"))" \
               "$users_arrayish"
            local result="$OUT"
            
            JqRawLines ".login" "$result"
            matches=("${OUTA[@]}")

            case "${#matches[@]}" in
                0) Fail "No $description found with login '$name_or_login' " \
                        "nor name matching '$name_or_login'" ;;
                1)
                    local login="${matches[0]}"

                    JqRaw ".name" "$result"
                    local name="$OUT"
                    
                    read -n1 -p "Found '$name' ($login) matching '$name_or_login', ok? [Y/n] "
                    if test "$REPLY" != ""
                    then
                        echo
                        if test "$REPLY" != y
                        then
                            exit 1
                        fi
                    fi
                    ;;
                *) Fail "Found several ${description}s with names matching " \
                        "'$name_or_login': ${matches[*]}" ;;
            esac
            ;;
        1) local login="${matches[0]}" ;;
        *) Fail "Found several ${description}s with login '$name_or_login'!?" ;;
    esac

    if ! [[ "$login" =~ ^[a-z0-9]+$ ]]
    then
        Fail "Bad login name '$login' found for $description '$name_or_login'"
    fi

    OUT="$login"
}

function gh_reviewers {
    GitHubInfoFromOrigin
    local endpoint="$OUT"
    local owner="$OUT2"
    local repo="$OUT3"
    local ssh_url="$OUT4"

    GetBranch
    local branch="$OUT"

    if ! GetPullRequestNumber "$endpoint" "$owner" "$repo" "$branch"
    then
        Fail "There's no PR number associated with working directory"
    fi
    local number="$OUT"

    GetReviewers "$endpoint" "$owner" "$repo" "$number"

    if (( ${#OUTA[@]} > 0 )); then
        printf "%s\n" "${OUTA[@]}"
    fi
}

function GetReviewers {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local pr_number="$4"
    shift 4
    
    local path=/repos/"$owner"/"$repo"/pulls/"$pr_number"/requested_reviewers
    GetRest "$endpoint" "$path"
    local json="$OUT"

    JqRawLines ".users[].login" "$json"
}

function gh_edit {
    local editor="${VISUAL:-${EDITOR}}"
    test "$editor" != "" || UsageError "EDITOR is not set"

    GetStatus
    local -a files=("${OUTA[@]}")
    local -A file_statuses=()
    CopyHashTo OUTH file_statuses

    local -A modified=()
    local file
    for file in "${files[@]}"
    do
        local status="${file_statuses[$file]:0:1}"
        case "$status" in
            A|M) modified["$file"]=1 ;;
        esac
    done

    Run exec "$EDITOR" "${!modified[@]}"
}

function gh_exec {
    "$@"
}

function AddReviewers {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local pr_number="$4"
    local comma_separated_list_of_reviewers="$5"
    
    GetReviewers "$endpoint" "$owner" "$repo" "$pr_number"
    local -A existing_reviewers=()
    local r
    for r in "${OUTA[@]}"; do
        echo "$r is already a reviewer"
        existing_reviewers["$r"]=1
    done

    local -a reviewers=()
    SplitBy "$comma_separated_list_of_reviewers" ,
    for r in "${OUTA[@]}"; do
        if test "${existing_reviewers[$r]}" == 1; then
            echo "$r already a reviewer"
        else
            reviewers+=("$r")
        fi
    done

    if (( ${#reviewers[@]} == 0 )); then
        return
    fi

    local escaped_reviewers_list=""

    local reviewer
    for reviewer in "${reviewers[@]}"
    do
        ToJsonString "$reviewer"
        local escaped_reviewer="$OUT"

        if test -z "$escaped_reviewers_list"
        then
            escaped_reviewers_list="$escaped_reviewer"
        else
            escaped_reviewers_list+=,"$escaped_reviewer"
        fi
    done

    local data="{\"reviewers\": [ $escaped_reviewers_list ]}"
    local path=/repos/"$owner"/"$repo"/pulls/"$pr_number"/requested_reviewers
    PostRest "$endpoint" "$path" -d "$data"

    echo "${reviewers[*]} set to review PR"
}

function gh_wait {
    local assignee= approve=false comment= merge=false ptal=false reviewers=
    while (($# > 0))
    do
        case "$1" in
            -A|--approve|+1|--lgtm)
                approve=true
                shift
                ;;
            -a|--assignee)
                assignee="$2"
                shift 2
                ;;
            -c|--comment)
                comment="$2"
                shift 2
                ;;
            -m|--merge)
                merge=true
                shift
                ;;
            -p|--ptal)
                ptal=true
                shift
                ;;
            -r|--reviewers)
                reviewers="$2"
                shift 2
                ;;
            *)
                break
                ;;
        esac
    done

    local wrong_usage=true

    if (( $# == 0 ))
    then
        GitHubInfoFromOrigin
        local endpoint="$OUT"
        local owner="$OUT2"
        local repo="$OUT3"

        GetBranch
        local branch="$OUT"

        if ! GetPullRequestNumber "$endpoint" "$owner" "$repo" "$branch"
        then
            Fail "There's no pull request associated with working directory"
        fi
        local number="$OUT"
        local url="$OUT2"

        wrong_usage=false
        echo "Found pull request $url"
    elif (( $# == 1 ))
    then
        if PullRequestInfo "$1"
        then
            local endpoint="$OUT"
            local owner="$OUT2"
            local repo="$OUT3"
            local branch="$OUT4"
            local number="$OUT5"
            wrong_usage=false
        fi
    fi

    if $wrong_usage
    then
        UsageError wait "Please specify which pull request to wait for"
    fi

    WaitForChecksThen "$endpoint" "$owner" "$repo" "$number" \
                      "$approve" "$comment" "$assignee" "$merge" "$ptal" \
                      "$reviewers"
}

declare -A UNOFFICIAL_COMMANDS=(
    [b]=gh_branch
    [branch]=gh_branch
    [c]=gh_commit
    [checkout]=gh_checkout
    [commit]=gh_commit
    [co]=gh_checkout
    [di]=gh_diff
    [diff]=gh_diff
    [drop]=gh_stack_drop
    [head]=gh_head
    [hi]=gh_history
    [history]=gh_history
    [i]=gh_info
    [info]=gh_info
    [is-clean]=IsClean
    [load]=gh_load
    [ls]=gh_stack_list
    [m]=gh_menu
    [menu]=gh_menu
    [pending]=gh_pending
    [pop]=gh_stack_pop
    [pr]=gh_pr
    [pub]=gh_submit
    [publish]=gh_submit
    [push]=gh_stack_push
    [repo]=gh_repo
    [resolve-pr]=gh_resolve_pr
    [resolve-wd]=gh_resolve_wd
    [revert]=gh_revert
    [s]=gh_stack
    [save]=gh_save
    [sdi]=gh_stack_diff
    [sdiff]=gh_stack_diff
    [stack]=gh_stack
    [stage]=Stage
    [stat]=gh_status
    [status]=gh_status
    [sub]=gh_submit
    [submit]=gh_submit
    [uncommit]=gh_uncommit
    [up]=gh_update
    [update]=gh_update)

declare -A DANGEROUS_COMMANDS=(
    [--help]=gh_help
    [-h]=gh_help
    [clean]=gh_clean
    [exec]=gh_exec
    [orgs]=gh_orgs
    [q]=gh_queue
    [repos]=gh_repos
    [rest]=gh_rest
    [reviewers]=gh_reviewers)

function Main {
    if (( $# == 0 ))
    then
        UsageError '' "No command given"
    fi

    local command="$1"
    shift

    local func="${COMMANDS[$command]}"
    if test "$func" == ""
    then
        func="${UNOFFICIAL_COMMANDS[$command]}"
        if test "$func" == ""
        then
            func="${DANGEROUS_COMMANDS[$command]}"
            if test "$func" == ""
            then
                UsageError '' "No such command '$command'"
            fi
        fi
    fi

    "$func" "$@"
}

Main "$@"
