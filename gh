#!/bin/bash
#
# TODO: Require jq, but only when actually needed by any command.

set -e

shopt -s nullglob

declare -r PROGRAM="${0##*/}"

declare -r DEFAULT_CONFIG_ROOT="$HOME"
declare -r CONFIG_ROOT="${GH_CONFIG_ROOT:-$DEFAULT_CONFIG_ROOT}"

declare -r CONFIG_FILE="$CONFIG_ROOT"/.gh

declare -r REPOS_FILE="$CONFIG_ROOT"/.gh-repos
declare -r OLD_REPOS_FILE="$CONFIG_ROOT"/.gh-repos.old

declare -r DIFF_FILE="$CONFIG_ROOT"/.gh.diff

declare -A COMMANDS=(
    [checkin]=gh_checkin
    [ci]=gh_checkin
    [clone]=gh_clone
    [commands]=gh_commands
    [h]=gh_help
    [help]=gh_help
    [refresh]=gh_refresh
    [wait]=gh_wait)
    
declare ECHO_COMMAND=false

declare PREVIEW=false

# Generic global variables to hold output from functions
declare OUT="" OUT2="" OUT3="" OUT4="" OUT5="" OUT6=""
declare -a OUTA=() OUTA2=()
declare -A OUTH=()

function Usage {
    local arg
    for arg in "$@"
    do
	printf "%s\n" "$arg"
    done

    cat <<EOF
Usage: $PROGRAM COMMAND [OPTION...] [ARG...]
Git and GitHub tool.

See '$PROGRAM help config' for how to set up config.

COMMANDS
  checkin|ci [OPTION...] [TITLE]
      Push local change to pull request and wait. See wait for options.
  clone PATTERN
      Clone ENDPOINT:OWNER/REPO matching PATTERN from $REPOS_FILE.
  commands
      Display available commands
  help [config]
  load [P]
      Apply diff from ~/.gh.diff. If P is specified and refers to a file,
      use that path instead, otherwise assume P is a hostname and scp its
      ~/.gh.diff to localhost.
  refresh
      Read $CONFIG_FILE and generate $REPOS_FILE cache.
  save [-n NAME] [PATH...]
      Save a diff to ~/.gh.diff. With NAME, save to ~/.gh.diff.NAME, or if NAME
      is a path save to that path. With PATH, only save a diff of those paths.
  wait [OPTION...] [PR_URL]
      Wait for checks to pass.
      Options are applied if and after the checks pass:
       --approve|-A|+1, approve PR
       --assignee|-a ASSIGNEE, assign PR to ASSIGNEE
       --comment|-c COMMENT, add comment
       --merge|-m, merge pull request, delete branch, and check out master
       --ptal|-p, ask reviewers and assignees to take another look at the PR
       --reviewers|-r REVIEWERS, comma-separated list of reviewers
EOF

    exit 1
}

function UsageError {
    local command="$1"
    shift
    
    if test "$command" == ""
    then
	local command_text=" of 'gh'"
    else
	local command_text=" of 'gh $command'"
    fi

    Fail "Bad invocation$command_text: " "$@" \
	     $'\n'"See '$PROGRAM help' for details"
}

function Fail {
    local arg
    for arg in "$@"
    do
	printf "%s" "$arg"
    done
    echo

    exit 1
}

function Format {
    local format="$1"
    shift

    local -A specifiers=()
    local assignment
    for assignment in "$@"
    do
	if ! [[ "$assignment" =~ ^(.)=(.*)$ ]]
	then
	    Fail "Bad specifier assignment '$assignment'"
	fi
	local specifier="${BASH_REMATCH[1]}"
	local value="${BASH_REMATCH[2]}"
	specifiers["$specifier"]="$value"
    done

    local text=""
    local state=normal
    local -i i=0
    for (( ; i < ${#format}; ++i ))
    do
	local char="${format:$i:1}"

	case "$state" in
	    normal)
		case "$char" in
		    %) state=specifier ;;
		    *) text+="$char" ;;
		esac
		;;
	    specifier)
		case "$char" in
		    %)
			text+="%"
			state=normal
			;;
		    *)
			local substitute="${specifiers[$char]}"
			if test -z "$substitute"
			then
			    Fail "Bad conversion specifier '$char'"
			fi
			text+="$substitute"
			state=normal
			;;
		esac
		;;
	esac
    done

    OUT="$text"
}

function SplitBy {
    local strings="$1"
    local separator="$2"

    local -a array=()

    # TODO: It may be easier to use IFS, but making sure it's unchanged on
    # return is painful.

    if (( ${#strings} > 0 ))
    then
	local suffix="$strings"
	while true
	do
	    local string="${suffix%%$separator*}"

	    # If suffix doesn't contain separator, string equals suffix. In
	    # either case, it is correct to...
	    array+=("$string")

	    if test "$string" == "$suffix"
	    then
		break
	    fi

	    local new_suffix="${suffix#$string$separator}"
	    if test "$new_suffix" == "$suffix"
	    then
		Fail "Internal error: Unable to split '$strings' by " \
		     "'$separator'"
	    fi

	    suffix="$new_suffix"
	done
    fi

    OUTA=("${array[@]}")
}

function Extract {
    local regex="$1"
    local format="$2"

    while read -r
    do
	if [[ "$REPLY" =~ $regex ]]
	then
	    local specifiers=()
	    local key
	    for key in "${!BASH_REMATCH[@]}"
	    do
		specifiers+=("$key=${BASH_REMATCH[$key]}")
	    done

	    Format "$format" "${specifiers[@]}"
	    printf "%s\n" "$OUT"
	fi
    done
}

function EchoCommand {
    printf "%q" "$1"
    shift

    local arg
    for arg in "$@"
    do
	printf " %q" "$arg"
    done
    printf "\\n"
}

function MaybeEchoCommand {
    if $ECHO_COMMAND
    then
	EchoCommand "$@"
    fi
}

function Run {
    MaybeEchoCommand "$@"
    "$@"
}

function RunOrFail {
    if ! "$@"
    then
	echo -n "Command failed: "
	EchoCommand "$@"
	exit 1
    fi
}

function CaptureStd {
    local -a command=("$@")

    local out
    if ! out=$("${command[@]}" 2>&1)
    then
	Fail "Command '${command[*]}' failed unexpectedly: '$out'"
    fi

    OUT="$out"
}

function CaptureStdLines {
    CaptureStd "$@"
    local out="$OUT"

    local -a lines=()
    if (( ${#out} > 0 ))
    then
	mapfile -t lines <<< "$out"
    fi

    OUTA=("${lines[@]}")
}

function PrintLines {
    local arg
    for arg in "$@"
    do
	printf "%s\n" "$arg"
    done
}

function Sort {
    local -a elements=("$@")

    OUTA=()
    mapfile -t OUTA <<< "$(PrintLines "${elements[@]}" | sort)"
}

function Match {
    local __Match_regex="$1"
    local __Match_text="$2"
    shift 2

    [[ "$__Match_text" =~ $__Match_regex ]]
    local -i __Match_status="$?"

    if test "$__Match_status" == 0
    then
	local -i __Match_index=1
	local __Match_variable_name
	for __Match_variable_name in "$@"
	do
	    if test "$__Match_variable_name" != ""
	    then
		local -n __Match_variable="$__Match_variable_name"
		__Match_variable="${BASH_REMATCH[$__Match_index]}"
	    fi
	    __Match_index+=1
	done
    elif test "$__Match_status" != 1
    then
	Fail "Bad regular expression: '$__Match_regex'"
    fi

    return "$__Match_status"
}

# Set OUT to a "JSON string" with the value of $1
# 
# Example: The string 'unescaped' defined as follows:
#     local unescaped='This is a "good" example
#     over two lines'
# would be escaped by ToJsonString to:
#     OUT='"This a \"good\" example\nover two lines'
function ToJsonString {
    local string="$1"

    local json_string="$string"
    json_string="${json_string//\\/\\\\}"
    json_string="${json_string//\"/\\\"}"

    local newline=$'\n'
    json_string="${json_string//$newline/\\n}"

    local tab=$'\t'
    json_string="${json_string//$tab/\\t}"

    OUT="\"$json_string\""
}

function Jq {
    local jq_expression="$1"
    local json="$2"
    shift 2

    local out
    if ! out=$(jq "$@" "$jq_expression" <<< "$json" 2>&1)
    then
	Fail "'jq' with expression '$jq_expression' failed on json '$json' " \
	     "printing '$out'"
    fi

    OUT="$out"
}

function JqRaw {
    Jq "$@" -r
}

function JqRawLines {
    local jq_expression="$1"
    local json="$2"

    JqRaw "$jq_expression" "$json"
    local out="$OUT"

    local -a lines=()

    if test "$out" != ""
    then
	while read -r
	do
	    local line="$REPLY"
	    lines+=("$line")
	done <<< "$out"
    fi

    OUTA=("${lines[@]}")
}

function ReadConfigAsString {
    if ! test -e "$CONFIG_FILE"
    then
	Fail "Please make a config file '$CONFIG_FILE'"
    fi

    OUT=$(< "$CONFIG_FILE")
}

function GetEndpoints {
    ReadConfigAsString
    local config="$OUT"

    JqRawLines ".endpoints | keys[]" "$config"
    # Forward OUTA
}

function ResolveEndpoint {
    local endpoint="$1"
    SanityCheckEndpoint "$endpoint"

    ReadConfigAsString
    local config="$OUT"

    ToJsonString "$endpoint"
    local name="$OUT"

    Jq ".endpoints.$endpoint" "$config"
    local json="$OUT"

    JqRaw .api_authority "$json"
    local api_authority="$OUT"
    local api_authority_regex='^[a-zA-Z0-9.:-]+$'
    if ! [[ "$api_authority" =~ $api_authority_regex ]]
    then
	Fail "Invalid api_authority found in $CONFIG_FILE for endpoint " \
	     "'$endpoint': Is expected to match " \
	     "'$api_authority_regex' but is '$api_authority'"
    fi

    JqRaw .user "$json"
    local user="$OUT"
    local user_regex='^[a-zA-Z0-9_-]+$'
    if ! [[ "$user" =~ $user_regex ]]
    then
	Fail "Invalid user found in $CONFIG_FILE for endpoint " \
	     "'$endpoint': Is expected to match " \
	     "'$user_regex' but is '$user'"
    fi

    JqRaw .token "$json"
    local token="$OUT"
    local token_regex='^[a-zA-Z0-9=]{40}$'
    if ! [[ "$token" =~ $token_regex ]]
    then
	Fail "Invalid token found in $CONFIG_FILE for endpoint " \
	     "'$endpoint': Is expected to match " \
	     "'$token_regex' but is '$token'"
    fi

    if test "$api_authority" == api.github.com
    then
	local rest_url="https://$api_authority"
	local graphql_url="https://$api_authority/graphql"
    else
	# WARNING: This is assuming GitHub Enterprise setup
	local rest_url="https://$api_authority/api/v3"
	local graphql_url="https://$api_authority/api/graphql"
    fi

    OUT="$rest_url"
    OUT2="$user"
    OUT3="$token"
    OUT4="$graphql_url"
}

function Curl {
    local url="$1"
    local token="$2"
    shift 2
    local -a args=("$@")

    local save_dir="$HOME/tmp/gh.cache"
    mkdir -p "$save_dir"

    # Note: Cannot use <<< with tr since it adds a newline
    local url_filename=$(printf "%s" "$url" | tr -c 'a-zA-Z0-9_-' '_')
    local command_file="$save_dir/$url_filename.command"
    local response_file="$save_dir/$url_filename.response"

    if $PREVIEW
    then
	local accept=application/vnd.github.thor-preview+json
    else
	local accept=application/vnd.github.v3+json
    fi

    local -a command=(
	curl
	--silent
	--fail
	--output "$response_file"
	--write-out "%{http_code}"
	-H "Content-Type: application/json"
	-H "Accept: $accept"
	-H "Authorization: token $token"
	"${args[@]}"
	"$url"
    )

    EchoCommand "${command[@]}" > "$command_file"
    # Avoid stale response_file in case it's not overwritten:
    rm -f "$response_file"

    local -i http_code=0
    MaybeEchoCommand "${command[@]}"
    if http_code=$("${command[@]}")
    then
	:
    else
	local -i status="$?"
	local message="Curl failed with status $status"

	if (( http_code > 0 ))
	then
	    message+=" and HTTP status code $http_code"
	fi

	message+=" for command:"$'\n'$(< "$command_file")

	if test -e "$response_file"
	then
	    local response=$(< "$response_file")
	    if (( ${#response} > 0 ))
	    then
		message+=$'\n'"With HTTP response body:"$'\n'"$response"
	    else
		message+=$'\n'"With empty HTTP response body"
	    fi
	else
	    message+=$'\n'"With absent HTTP response body"
	fi

	Fail "$message"
    fi

    if (( http_code < 200 || http_code >= 300 ))
    then
	Fail "HTTP response code $http_code for command: ${command[*]}"
    fi

    local response
    if ! response=$(< "$response_file")
    then
	Fail "Failed to read '$response_file'"
    fi

    if ! jq . <<< "$response" &> /dev/null
    then
	Fail "Response is invalid JSON: '$response'"
    fi

    OUT="$response"
}

function CurlRest {
    local endpoint="$1"
    local path="$2" # E.g. /repos/user
    shift 2

    ResolveEndpoint "$endpoint"
    local rest_url="$OUT"
    local user="$OUT2"
    local token="$OUT3"

    local url="${rest_url%/}/${path#/}"

    Curl "$url" "$token" "$@"
}

function GetRest {
    CurlRest "$@" -X GET 
}

# Usage: PostRest ENDPOINT PATH -d '...' ...
function PostRest {
    CurlRest "$@" -X POST 
}

function PutRest {
    CurlRest "$@" -X PUT
}

function DeleteRest {
    CurlRest "$@" -X DELETE
}

function QueryGraph {
    local endpoint="$1"
    local query="$2"
    shift 2

    ToJsonString "$query"
    local query_json="$OUT"
    local json="{\"query\": $query_json}"

    ResolveEndpoint "$endpoint"
    local user="$OUT2"
    local token="$OUT3"
    local graphql_url="$OUT4"

    Curl "$graphql_url" "$token" "$@" -X POST -d "$json"
    # OUT="$response"
}

function QueryGraphList {
    local endpoint="$1"
    local query_prefix="$2"
    local query_suffix="$3"
    local jq_path="$4"
    shift 4

    local jq_nodes=""

    local cursor_text=""
    while true
    do
	local query="$query_prefix$cursor_text$query_suffix"
	QueryGraph "$endpoint" "$query" "$@"
	local response="$OUT"

	Jq "$jq_path" "$response"
	local graphql_array="$OUT"

	Jq '.nodes[]' "$graphql_array"
	jq_nodes+="$OUT"$'\n'

	Jq .pageInfo.hasNextPage "$graphql_array"
	local has_next_page="$OUT"
	case "$has_next_page" in
	    true) : ;;
	    false) break ;;
	    *)
		Fail "Bad value of hasNextPage for GraphQL array " \
		     "'$graphql_array'"
		;;
	esac

	Jq .pageInfo.endCursor "$graphql_array"
	local end_cursor_json="$OUT"
	cursor_text=" after:$end_cursor_json"
    done

    OUT="$jq_nodes"
}

function GetOrgs {
    local endpoint="$1"

    ResolveEndpoint "$endpoint"
    local user="$OUT2"

    ToJsonString "$user"
    local user_json="$OUT"

    local query="
query {
  user(login:$user_json) {
    organizations(first:100) {
      totalCount
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        name
        login
        url
      }
    }
  }
}
"

    QueryGraph "$endpoint" "$query"
    local orgs_json="$OUT"

    JqRawLines ".data.user.organizations.nodes[].login" "$orgs_json"
    local -a orgs=("${OUTA[@]}")

    OUTA=("${orgs[@]}")
}

function gh_orgs {
    if (( $# != 1 ))
    then
	UsageError orgs "Expected exactly one argument: the endpoint name"
    fi

    local endpoint="$1"

    GetOrgs "$endpoint"
    PrintLines "${OUTA[@]}"
}

function GetRepos {
    local endpoint="$1"
    local owner="$2" # organization or user
    
    local -a repos=()

    ToJsonString "$owner"
    local owner_json="$OUT"

    local after_text=""

    while true
    do
	local query="
query {
  repositoryOwner(login:$owner_json) {
    repositories(first:100$after_text) {
      pageInfo {
        endCursor
        hasNextPage
      }
      nodes {
        owner {
          login
        }
        name
      }
    }
  }
}"

	QueryGraph "$endpoint" "$query"
	local response_json="$OUT"

	# The weirdest thing: With owner_json being e.g. 'hakon', I get some
	# owner.login which are != 'hakon'. It's not clear why these extra
	# repositories are output. Depends on permissions?
	#
	# Therefore, we will select only those having .owner.login equal to
	# $owner.

	JqRawLines ".data.repositoryOwner.repositories.nodes[] | select(.owner.login == $owner_json) | .name" \
		   "$response_json"
	repos+=("${OUTA[@]}")

	JqRaw ".data.repositoryOwner.repositories.pageInfo.hasNextPage" \
	      "$response_json"
	local has_next_page="$OUT"

	case "$has_next_page" in
	    true) : ;;
	    false) break ;;
	    *) Fail "Bas hasNextPage value in response: '$has_next_page'" ;;
	esac

	JqRaw ".data.repositoryOwner.repositories.pageInfo.endCursor" \
	      "$response_json"
	local end_cursor="$OUT"

	if ! Match '^[a-zA-Z0-9=]+$' "$end_cursor"
	then
	    Fail "Bas endCursor value in response: '$end_cursor'"
	fi

	ToJsonString "$end_cursor"
	local end_cursor_json="$OUT"
	after_text=" after:$end_cursor_json"
    done

    OUTA=("${repos[@]}")
    Sort "${OUTA[@]}"
}

function gh_repos {
    if (( $# != 2 ))
    then
	UsageError repos "Command takes exactly two arguments"
    fi

    local endpoint="$1"
    local owner="$2"

    GetRepos "$endpoint" "$owner"
    PrintLines "${OUTA[@]}"
}

function gh_refresh {
    if (( $# != 0 ))
    then
	UsageError refresh "Takes exactly 0 arguments"
    fi

    local repos_workfile="$HOME/.gh-repos.tmp"
    > "$repos_workfile"

    GetEndpoints
    local -a endpoints=("${OUTA[@]}")

    local endpoint
    for endpoint in "${endpoints[@]}"
    do
	if [[ "$endpoint" =~ ' ' ]]
	then
	    Fail "The file format assumes endpoint '$endpoint' doesn't " \
		 "doesn't contains space"
	fi

	GetOrgs "$endpoint"
	local -a orgs=("${OUTA[@]}")

	ResolveEndpoint "$endpoint"
	local user="$OUT2"

	local -a owners=("$user" "${orgs[@]}")

	# Hack:
	#  - GraphQL DOESN'T support providing ssh_url for a repo.
	#  - So we must use REST API.
	#  - Either we list all repos with heavy-weight REST API, or
	#  - as we choose to do, we get ssh_url for one repo per endpoint,
	#    and guess the ssh_url for all others.
	local ssh_url_prefix="" ssh_url_suffix=""

	local owner
	for owner in "${owners[@]}"
	do
	    if [[ "$owner" =~ ' ' ]]
	    then
		Fail "The file format assumes owner '$owner' doesn't " \
		     "doesn't contains space"
	    fi

	    GetRepos "$endpoint" "$owner"
	    local -a repos=("${OUTA[@]}")

	    if (( ${#repos[@]} == 0 ))
	    then
		# No point in proceeding
		continue
	    fi

	    if test "$ssh_url_prefix" == ""
	    then
		local example_repo="${repos[0]}"
		GetRest "$endpoint" "/repos/$owner/$example_repo"
		local json="$OUT"

		JqRaw .ssh_url "$json"
		local ssh_url="$OUT"

		# This is a terrible regex.
		local regex="^(.*)$owner/$example_repo(.*)"
		if ! Match "$regex" "$ssh_url" \
		     ssh_url_prefix ssh_url_suffix
		then
		    Fail "Unexpected form of ssh_url doesn't match regex " \
			 "'$regex': '$ssh_url'"
		fi
	    fi

	    local repo
	    for repo in "${repos[@]}"
	    do
		if [[ "$repo" =~ ' ' ]]
		then
		    Fail "The file format assumes repo '$repo' doesn't " \
			 "doesn't contains space"
		fi

		local ssh_url="${ssh_url_prefix}$owner/$repo$ssh_url_suffix"

		if [[ "$ssh_url" =~ ' ' ]]
		then
		    Fail "The file format assumes ssh_url '$ssh_url' doesn't " \
			 "doesn't contains space"
		fi

		printf "%s %s %s %s\n" "$endpoint" "$owner" "$repo" "$ssh_url" \
		       >> "$repos_workfile"
	    done
	done
    done

    cp "$REPOS_FILE" "$OLD_REPOS_FILE"
    sort "$repos_workfile" > "$REPOS_FILE"
    rm "$repos_workfile"
}

function GitHubInfoFromOrigin {
    # Unfortunately get-url isn't supported by git on RHEL 7, so we have to
    # extract URL from 'git remote -v'.
    local remote_url
    local fetch_url_regex='^origin'$'\t''(.*) \(fetch\)$'
    if ! remote_url=$(git remote -v | Extract "$fetch_url_regex" "%1")
    then
	Fail "Failed to get origin remote URL"
    fi

    AssertReposFile

    local endpoint="" owner="" repo="" ssh_url=""
    while read -r endpoint owner repo ssh_url
    do
	if test "$ssh_url" == "$remote_url"
	then
	    OUT="$endpoint"
	    OUT2="$owner"
	    OUT3="$repo"
	    OUT4="$ssh_url"
	    return
	fi
    done < "$REPOS_FILE"

    Fail "Failed to find any repositories matching current git repo"
}	    

function gh_rest {
    if (( $# < 2 ))
    then
	UsageError rest "Takes at least 2 arguments"
    fi

    local endpoint="$1"
    local path="$2"
    shift 2

    GetRest "$endpoint" "$path" "$@"
    printf "%s\n" "$OUT"
}

function AssertReposFile {
    if ! test -r "$REPOS_FILE"
    then
	Fail "Repository summary file not generated, please run " \
	     "'gh refresh'"
    fi
}

function SanityCheckEndpoint {
    local endpoint="$1"

    local endpoint_regex='^[a-zA-Z0-9_-]+$'
    if ! [[ "$endpoint" =~ $endpoint_regex ]]
    then
	Fail "Bad endpoint '$endpoint': Must match '$endpoint_regex'"
    fi
}

function SanityCheckOwner {
    local owner="$1"

    local owner_regex='^[a-zA-Z0-9_-]+$'
    if ! [[ "$owner" =~ $owner_regex ]]
    then
	Fail "Bad owner '$owner': Must match '$owner_regex'"
    fi
}

function SanityCheckRepo {
    local repo="$1"

    local repo_regex='^[a-zA-Z0-9_-]+$'
    if ! [[ "$repo" =~ $repo_regex ]]
    then
	Fail "Bad repo '$repo': Must match '$repo_regex'"
    fi
}

function ValidateRepo {
    SanityCheckEndpoint "$1"
    SanityCheckOwner "$2"
    SanityCheckRepo "$3"
}

function PrintCommandsOfUnsorted {
    # Maps a command function to a space-separated list of commands
    local -A commands_by_function=()

    local table
    for table in "$@"
    do
	# "$table" expands to e.g. "COMMANDS"
	eval "local -a commands=(\"\${!$table[@]}\")"
	local command
	for command in "${commands[@]}"
	do
	    eval "local func=\"\${$table[$command]}\""

	    if ! [[ "$func" =~ ^[a-zA-Z0-9_]+$ ]]
	    then
		Fail "Internal error: Bad function name '$func'"
	    fi

	    if test "${commands_by_function[$func]}" == ""
	    then
		commands_by_function["$func"]+="$command"
	    else
		commands_by_function["$func"]+=" $command"
	    fi
	done
    done

    local func
    for func in "${!commands_by_function[@]}"
    do
	# Poor man's sorting...

	local -i max_length=0
	local -A by_length=()

	local command
	# yes, commands_by_function is supposed to be unescaped
	for command in ${commands_by_function["$func"]}
	do
	    local -i length="${#command}"
	    # Again, poor man's sorting. Try to print proper commands first,
	    # then long options, then short options.
	    case "$command" in
		--*) length+=10 ;;
		-*) length+=0 ;;
		*) length+=20 ;;
	    esac
	    if (( length > max_length ))
	    then
		max_length=length
	    fi

	    if test "${by_length[$length]}" != ""
	    then
		Fail "Internal error: length of equivalent commands " \
		     "'$command' and '${by_length[$length]}'"
	    fi
	    by_length["$length"]="$command"
	done

	printf "%q" "${by_length[$max_length]}"

	local -i length=$(( max_length - 1 ))
	while (( length > 0 ))
	do
	    local command="${by_length[$length]}"
	    if test "$command" != ""
	    then
		printf ", %q" "${by_length[$length]}"
	    fi
	    length=$(( length - 1 ))
	done

	printf "\n"
    done
}

function PrintCommandsOf {
    if test -t 1
    then
	PrintCommandsOfUnsorted "$@" | sort | pr -4 -w 80 -t -T
    else
	PrintCommandsOfUnsorted "$@" | sort
    fi
}

function gh_commands {
    local -i verbosity=0

    while (( $# > 0 ))
    do
	case "$1" in
	    -v) verbosity+=1 ;;
	    -vv) verbosity+=2 ;;
	    *) UsageError commands "Unknown argument '$1'" ;;
	esac
	shift
    done

    case "$verbosity" in
	0) PrintCommandsOf COMMANDS ;;
	1) PrintCommandsOf COMMANDS UNOFFICIAL_COMMANDS ;;
	*) PrintCommandsOf COMMANDS UNOFFICIAL_COMMANDS DANGEROUS_COMMANDS ;;
    esac
}

function gh_clone {
    if (( $# != 1 ))
    then
	UsageError clone "Exactly one argument expected"
    fi
    local pattern="$1"

    AssertReposFile

    local -a matched_specs=()
    local -a matched_lines=()
    local endpoint owner repo ssh_url
    while read -r endpoint owner repo ssh_url
    do
	local spec="$endpoint:$owner/$repo"
	if [[ "$spec" =~ $pattern ]]
	then
	    matched_specs+=("$spec")
	    matched_lines+=("$endpoint $owner $repo $ssh_url")
	fi
    done < "$REPOS_FILE"

    local -i num_matches="${#matched_lines[@]}"
    case "$num_matches" in
	0)
	    Fail "Pattern '$pattern' didn't match any 'owner/repositories', " \
		 "see $REPOS_FILE for the list of all repositories"
	    ;;
	1) : ;;
	*)
	    local message=""
	    local spec
	    for spec in "${matched_specs[@]}"
	    do
		message+=$'\n'"$spec"
	    done
	    Fail "Too many repository specs matched '$pattern':$message"
	    ;;
    esac

    read -r endpoint owner repo ssh_url <<< "${matched_lines[0]}"

    ValidateRepo "$endpoint" "$owner" "$repo"

    Run git clone "$ssh_url" "$endpoint/$owner/$repo"
}

function gh_help {
    if (( $# == 0 ))
    then
	Usage
    fi

    local topic="$1"
    shift

    local help_function=gh_help_"$topic"
    if ! declare -f "$help_function" &> /dev/null
    then
	UsageError help "Unknown help topic '$topic'"
    fi

    "$help_function" "$@"
}

function gh_help_config {
    cat <<EOF
The config file .gh should be defined in, and the repo cache .gh-repos is saved
in, the config root directory.  The config root is by default
$DEFAULT_CONFIG_ROOT, but can be overridden by setting GH_CONFIG_ROOT.

Example config:
{
    "endpoints": {
        "github": {
            "api_authority": "api.github.com",
            "user": "hakonhall",
            "token": "7fe3...",
            "owners": {
                "vespa-engine": {
                    "checks": [
                        "^cla/licenses\$"
                    ]
                    "repos": {
                        "vespa": {
                            "checks": [
                                "^continuous-integration/travis-ci/pr\$",
                                "^cla/licenses$"
                            ]
                        }
                    }
                }
            }
        }
    }
}

"token" is a personal access token.
"checks" can be put either at root level, in an endpoint, in an owner, or in a
repo.
EOF
}

function GetBranch {
    if ! OUT=$(git rev-parse --abbrev-ref HEAD)
    then
	Fail "Failed to get branch with 'git rev-parse --abbrev-ref HEAD'"
    fi
}

function gh_info {
    if (( $# != 0 ))
    then
	UsageError undo "Command takes exactly zero arguments"
    fi

    GitHubInfoFromOrigin
    local endpoint="$OUT"
    local owner="$OUT2"
    local repo="$OUT3"
    local ssh_url="$OUT4"

    GetBranch
    local branch="$OUT"

    if test "$branch" == master
    then
	local branch_text=""
    else
	local branch_text="#$branch"
    fi

    echo "$endpoint:$owner/$repo$branch_text$upstream_text"

    gh_status
}

function gh_load {
    local diff_file="$DIFF_FILE"

    if (( $# > 0 ))
    then
	if test -r "$1" && (( $# == 1 ))
	then
	    diff_file="$1"
	else
	    local -a scp_options=()
	    while test "${1:0:1}" == -
	    do
		scp_options+=("$1")
		shift
	    done

	    if (( $# == 0 ))
	    then
		UsageError load "Missing hostname argument"
	    elif (( $# > 1 ))
	    then
		UsageError load "Too many arguments"
	    fi
	    local hostname="$1"

	    rm -f "$DIFF_FILE"

	    RunOrFail scp "${scp_options[@]}" "$hostname:$DIFF_FILE" "$DIFF_FILE"
	fi
    fi

    if ! test -r "$diff_file"
    then
	Fail "There is no diff file at $diff_file"
    fi

    if RunOrFail git apply "$diff_file"
    then
	echo "$diff_file has been applied"
    else
	Fail "Failed to load $diff_file"
    fi
}

function PendingUpstreamCommits {
    local branch="$1"

    local upstream=""
    if ! upstream=$(git rev-parse --symbolic-full-name "$branch"@{upstream} \
		    2>/dev/null)
    then
	Fail "Current branch '$branch' doesn't track any upstream"
    fi

    if ! [[ "$upstream" =~ ^refs/remotes/origin/ ]]
    then
	Fail "Upstream of current branch ($branch) is not at 'origin' " \
	     "remote: refuse to run"
    fi

    RunOrFail git fetch --quiet origin

    OUT="$upstream"
    OUT2="$branch"
}

function gh_pending {
    if (( $# != 0 ))
    then
	UsageError undo "Command takes exactly zero arguments"
    fi

    GetBranch
    local branch="$OUT"

    PendingUpstreamCommits "$branch"
    local upstream="$OUT"

    CaptureStd git rev-list --count "$branch".."$upstream"
    local -i pending_commits="$OUT"

    case "$pending_commits" in
	0) echo "There are no pending upstream commits" ;;
	1) echo "There us 1 pending upstream commit" ;;
	*) echo "There are $pending_commits pending upstream commits" ;;
    esac
}

function PullRequestInfo {
    local pr_id="$1"

    local wrong_usage=true
    if [[ "$pr_id" =~ ^[0-9]+$ ]]
    then
	local number="$pr_id"

	GitHubInfoFromOrigin
	local endpoint="$OUT"
	local owner="$OUT2"
	local repo="$OUT3"
	
	if TryGetPullRequest "$endpoint" "$owner" "$repo" "$number"
	then
	    local branch="$OUT"
	    wrong_usage=false
	fi
    elif FindEndpointIfPullRequestUrl "$pr_id"
    then
	local endpoint="$OUT"
	local owner="$OUT2"
	local repo="$OUT3"
	local number="$OUT4"
	local branch="$OUT5"
	wrong_usage=false
    fi

    if $wrong_usage
    then
	return 1
    else
	OUT="$endpoint"
	OUT2="$owner"
	OUT3="$repo"
	OUT4="$branch"
	OUT5="$number"
	return 0
    fi
}

function gh_resolve_pr {
    local format=$'endpoint: %e\nowner: %o\nrepo: %r\nnumber: %n\n'
    while (( $# > 0 ))
    do
	case "$1" in
	    -f|--format)
		format="$2"
		shift 2
		;;
	    *) break ;;
	esac
    done

    if (( $# == 0 ))
    then
	UsageError resolve-pr "Missing URL or number of pull request"
    elif (( $# > 1 ))
    then
	UsageError resolve-pr "Too many arguments"
    fi
    local pull_request_url_or_number="$1"

    if PullRequestInfo "$pull_request_url_or_number"
    then
	Format "$format" e="$OUT" o="$OUT2" r="$OUT3" b="$OUT4" n="$OUT5"
	printf "%s" "$OUT"
    else
	Fail "Failed to find pull request identified by " \
	     "'$pull_request_url_or_number'"
    fi
}

function gh_resolve_wd {
    local format=$'endpoint: %e\nowner: %o\nrepo: %r\nbranch: %b\nssh-url: %s\n'
    while (( $# > 0 ))
    do
	case "$1" in
	    -f|--format)
		format="$2"
		shift 2
		;;
	    *) break ;;
	esac
    done

    if (( $# > 0 ))
    then
	UsageError resolve-wd "Too many arguments"
    fi

    GitHubInfoFromOrigin
    local endpoint="$OUT"
    local owner="$OUT2"
    local repo="$OUT3"
    local ssh_url="$OUT4"

    GetBranch
    local branch="$OUT"

    Format "$format" e="$endpoint" o="$owner" r="$repo" b="$branch" s="$ssh_url"
    printf "%s" "$OUT"
}

function gh_revert {
    if (($# == 0))
    then
        Run git reset --quiet --hard
        # Resetting an added file/directory leaves it as untracked, so we need
        # to clean. Unfortunately, cleaning may also remove already untracked
        # files.
        # -f:  Force
        # -d:  Remove directories
        Run git clean --quiet -fd
    else
	# TODO: For each file in "$@", we should check it's status: whether
	# it's added, modified, deleted (, attribute change?), and this may be
	# different in wd vs index. The result of each such file should be an
	# action, like remove file from index and wd.

	Stage

	local -A file_status=()

	CaptureStdLines git status --short
	local -a lines=("${OUTA[@]}")

	local line
	for line in "${lines[@]}"
	do
	    if [[ "$line" =~ ^(R)'  '([^' ']+)' -> '([^' ']+)$ ]]
	    then
		local status="${BASH_REMATCH[1]}"
		local from_path="${BASH_REMATCH[2]}"
		local to_path="${BASH_REMATCH[3]}"

		from_path=$(realpath -m "$from_path")
		file_status["$from_path"]="$status"

		to_path=$(realpath -m "$to_path")
		file_status["$to_path"]="$status"
	    elif [[ "$line" =~ ^(.)'  '([^' ']+)$ ]]
	    then
		local status="${BASH_REMATCH[1]}"
		local path="${BASH_REMATCH[2]}"
		path=$(realpath -m "$path")

		case "$status" in
		    M|A|D) file_status["$path"]="$status" ;;
		    *) Fail "Unknown git status '$status' for '$path'" ;;
		esac
	    else
		Fail "Badly formatted status line, perhaps file path " \
		     "contains space or a rename? line: '$line'"
	    fi
	done

	local path
	for path in "$@"
	do
	    path=$(realpath -m "$path")

	    local status="${file_status[$path]}"
	    case "$status" in
		M|D)
		    Run git reset -q HEAD "$path"
		    Run git checkout -q "$path"
		    ;;
		A)
		    Run git reset -q HEAD "$path"
		    Run rm "$path"
		    ;;
		R)
		    Fail "Modifications on renamed files is not yet supported"
		    ;;
		*) Fail "There's a path mismatch!?"
	    esac
	done
    fi
}

function gh_save {
    local diff_file="$DIFF_FILE"

    while (( $# > 0 ))
    do
	case "$1" in
	    -n)
		if [[ "$2" =~ ^[a-zA-Z0-9_-]+$ ]]
		then
		    local diff_file=~/.gh.diff."$2"
		else
		    local diff_file="$2"
		    local parent_dir=$(dirname "$diff_file")
		    if ! test -d "$parent_dir"
		    then
			Fail "Parent directory of '$diff_file' doesn't exist"
		    fi
		fi
		shift 2
		;;
	    -*) Fail "Unknown option '$1'" ;;
	    *) break ;;
	esac
    done

    Stage
    git diff HEAD "$@" > "$diff_file"
    echo "Saved to $diff_file"
}

function gh_status {
    Stage
    Run git status --short
}

function GetGitRootRelative {
    local out
    if ! out=$(git rev-parse --show-cdup 2>&1)
    then
	Fail "Not in a git repository? 'git rev-parse --show-cdup' failed: $out"
    fi

    # If PWD is in root, out is empty.
    local root="${out%/}"
    if ((${#root} == 0))
    then
        root=.
    fi

    if ! [ -d "$root" ]
    then
        Fail "Failed to find root, '$root' not a directory"
    fi

    OUT="$root"
}

function Stage {
    GetGitRootRelative
    local root="$OUT"

    local -a root_args=()
    if [ "$root" == . ]
    then
        # TODO: Shouldn't this be (.) ?
        root_args=()
    elif [[ "$root" =~ ^- ]]
    then
        root_args=(-- "$root")
    else
        root_args=("$root")
    fi

    Run git reset --quiet "${root_args[@]}"
    Run git add --all "${root_args[@]}"
}

function IsClean {
    CaptureStd git status --short
    if test "$OUT" == ""
    then
	return 0
    else
	return 1
    fi
}

function GetPullRequestNumber {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local branch="$4"

    ToJsonString "$owner"
    local owner_json="$OUT"
    ToJsonString "$repo"
    local repo_json="$OUT"
    ToJsonString "$branch"
    local branch_json="$OUT"

    local query="
query {
  repository(owner:$owner_json name: $repo_json) {
    pullRequests(first:1 headRefName: $branch_json) {
      pageInfo {
        hasNextPage
      }
      nodes {
        number
        url
      }
    }
  }
}"
    
    QueryGraph "$endpoint" "$query"
    local json="$OUT"

    JqRaw ".data.repository.pullRequests.pageInfo.hasNextPage" "$json"
    case "$OUT" in
	false) : ;;
	true) Fail "More than one pull requests are open for current branch" ;;
	*) Fail "Failed to get pull request list: '$json'" ;;
    esac

    Jq ".data.repository.pullRequests.nodes | length" "$json"
    case "$OUT" in
	0) return 1 ;;
	1) : ;;
	*) Fail "Failed to get pull request list: '$json'" ;;
    esac

    JqRaw ".data.repository.pullRequests.nodes[].number" "$json"
    local number="$OUT"

    if test "$number" == ""
    then
	return 1
    elif ! [[ "$number" =~ ^[0-9]+$ ]]
    then
	Fail "Failed to get pull request number: '$json'"
    fi

    JqRaw ".data.repository.pullRequests.nodes[].url" "$json"
    local url="$OUT"

    if ! [[ "$url" =~ ^http ]]
    then
	Fail "Failed to get pull request URL: '$json'"
    fi

    OUT="$number"
    OUT2="$url"
}

function RawCreatePullRequest {
    local destination="$1"
    local owner="$2"
    local repo="$3"
    ToJsonString "$4"
    local branch_to_review="$OUT"
    ToJsonString "$5"
    local merge_branch="$OUT"
    ToJsonString "$6"
    local title="$OUT"
    ToJsonString "$7"
    local body="$OUT"

    local data="{
  \"head\": $branch_to_review,
  \"base\": $merge_branch,
  \"title\": $title,
  \"body\": $body
}"

    PostRest "$endpoint" "/repos/$owner/$repo/pulls" -d "$data"
    local json="$OUT"

    Jq .number "$json"
    local number="$OUT"

    JqRaw .html_url "$json"
    local url="$OUT"

    OUT="$number"
    OUT2="$url"
}

function CreatePullRequest {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local branch="$4"

    local destination_branch="master"

    # TODO: If more than 1 commit ahead of origin/master, we should open an
    # editor to specify title and body.

    local title
    title=$(git log -1 --format=%s HEAD)

    local body
    body=$(git log -1 --format=%b HEAD)
    if [[ "$body" =~ ^[' '$'\n'$'\r']+$ ]]
    then
	body=""
    fi

    RawCreatePullRequest "$destination" "$owner" "$repo" "$branch" \
			 "$destination_branch" "$title" "$body"
    # Pass through output variables
}

function gh_help_checkin {
    # Covered by Usage
    Usage
}

function gh_checkin {
    local approve=false assignee="" comment="" merge=false ptal=false title=""
    local escaped_edit_option= reviewers=""
    while (( $# > 0 ))
    do
	case "$1" in
	    --)
		shift
		break
		;;
	    -A|--approve|+1)
		approve=true
		shift
		;;
	    -a|--assignee)
		assignee="$2"
		shift 2
		;;
	    -c|--comment)
		comment="$2"
		shift 2
		;;
	    -e|--edit)
		escaped_edit_option=--edit
		shift
		;;
	    -h|--help) gh_help checkin ;;
	    -m|--merge)
		merge=true
		shift
		;;
	    -p|--ptal)
		ptal=true
		shift
		;;
	    -r|--reviewers)
		reviewers="$2"
		shift 2
		;;
	    -*) UsageError checkin "Unknown option '$1'" ;;
	    *) break ;;
	esac
    done

    GitHubInfoFromOrigin
    local endpoint="$OUT"
    local owner="$OUT2"
    local repo="$OUT3"
    local ssh_url="$OUT4"

    # This check has to be done before any mutable operations: the below branch
    # creation.
    if test "$assignee" != ""
    then
	LookupAssignee "$endpoint" "$owner" "$repo" "$assignee"
	assignee="$OUT"
    fi

    # This check has to be done before any mutable operations: the below branch
    # creation.
    if test "$reviewers" != ""
    then
	LookupReviewers "$endpoint" "$owner" "$repo" "$reviewers"
	reviewers="$OUT"
    fi

    local known_to_be_dirty=false

    GetBranch
    local branch="$OUT"

    if test "$branch" == master
    then
	if IsClean
	then
	    Fail "On master branch, and there's nothing to commit"
	fi
	known_to_be_dirty=true

	if (( $# != 1 ))
	then
	    UsageError checkin "Missing TITLE argument"
	fi
	local title="$1"

	branch="${title,,}"
	branch=$(printf "%s" "$branch" | tr ' ' - | tr -Cd '[:alnum:]-')
	if test "$branch" == ""
	then
	    Fail "Failed to find a good branch name from the title '$title'"
	fi

	ResolveEndpoint "$endpoint"
	local user="$OUT2"

	branch="$user/$branch"

	Stage
	git stash save --quiet --include-untracked
	if ! git checkout --quiet -b "$branch"
	then
	    echo "Error checking out new branch!"
	    echo "To retrieve your work, issue 'git stash pop'"
	    exit 1
	fi
	git stash pop --quiet

	Stage
        git commit --quiet $escaped_edit_option -m "$title"
    elif ! IsClean
    then
	local -a args=()
	case "$#" in
	    0) : ;;
	    1) args+=(-m "$1") ;;
	    *) UsageError checkin "Too many arguments" ;;
	esac

	Stage
        git commit --quiet $escaped_edit_option "${args[@]}"
    elif (( $# != 0 ))
    then
	UsageError checkin "Too many arguments: No local changes but " \
		   "TITLE given"
    fi
    
    git push -q -u origin "$branch"

    if GetPullRequestNumber "$endpoint" "$owner" "$repo" "$branch"
    then
	local number="$OUT"
	local url="$OUT2"
	echo "Found pull request $url"
    else
	CreatePullRequest "$endpoint" "$owner" "$repo" "$branch"
	local number="$OUT"
	local url="$OUT2"
	echo "Created pull request $url"
    fi

    WaitForChecksThen "$endpoint" "$owner" "$repo" "$number" \
		      "$approve" "$comment" "$assignee" "$merge" "$ptal" \
		      "$reviewers"
}

function gh_undo {
    if (( $# > 0 ))
    then
	UsageError undo "Command takes exactly zero arguments"
    fi

    git reset --soft HEAD^
    Stage
}

function gh_clean_branch {
    CaptureStdLines git branch
    local -a lines=("${OUTA[@]}")

    local line
    for line in "${lines[@]}"
    do
	if ! [[ "$line" =~ ^('* '|'  ')([^' ']+) ]]
	then
	    Fail "Unexpected format for line output by 'git branch': '$line'"
	fi

	local branch="${BASH_REMATCH[2]}"
	if test "${BASH_REMATCH[1]}" == '  '
	then
	    if ! git branch --quiet -d "$branch" &> /dev/null
	    then
		if ! read -n1 -p "Force-delete '$branch'? [Y/n] "
		then
		    echo
		    Fail "Failed to read answer"
		fi

		case "$REPLY" in
		    "") : ;;
		    y|Y) echo ;;
		    *)
			echo
			continue
			;;
		esac

		if ! git branch --quiet -D "$branch"
		then
		    # There should already be some error messages printed
		    Fail "Aborting"
		fi
	    fi

	    echo "Removed '$branch'"
	fi
    done
}

function gh_branch {
    local clean=false

    while (( $# > 0 ))
    do
	case "$1" in
	    --clean) clean=true ;;
	    *) break ;;
	esac
	shift
    done

    if (( $# > 0 ))
    then
	UsageError branch "Too many arguments"
    fi

    if $clean
    then
	if gh_clean_branch
	then
	    return 0
	else
	    return $?
	fi
    fi

    GetBranch
    echo "$OUT"
}

function gh_checkout {
    if (( $# != 1 ))
    then
	UsageError checkout "Command takes exactly one argument"
    fi
    local branch_or_pr_number_or_pr_url="$1"

    local need_to_pop=false
    if ! IsClean
    then
	git stash save --quiet
	need_to_pop=true
    fi

    local pending_error_message=
    if ! git checkout --quiet "$branch_or_pr_number_or_pr_url" 2> /dev/null
    then
	if PullRequestInfo "$branch_or_pr_number_or_pr_url"
	then
	    pr_endpoint="$OUT"
	    pr_owner="$OUT2"
	    pr_repo="$OUT3"
	    pr_branch="$OUT4"
	    pr_number="$OUT5"

	    GitHubInfoFromOrigin
	    local current_endpoint="$OUT"
	    local current_owner="$OUT2"
	    local current_repo="$OUT3"

	    if test "$pr_endpoint" == "$current_endpoint" && \
		    test "$pr_owner" == "$current_owner" && \
		    test "$pr_repo" == "$current_repo"
	    then
		# The pull request may exist on origin but may not yet have
		# been pulled.
		# TODO: Verify upstream is origin.
		git fetch -q origin

		echo "Checking out branch $pr_branch"
		if ! git checkout -q "$pr_branch"
		then
		    pending_error_message="Failed to check out '$pr_branch'"
		fi
	    else
		pending_error_message="Pull request '$branch_or_pr_number_or_pr_url' refers to a different repository"
	    fi
	else
	    pending_error_message="'$branch_or_pr_number_or_pr_url' is neither a branch, PR number, or PR URL"
	fi
    fi

    if test -n "$pending_error_message"
    then
	if $need_to_pop
	then
	    pending_error_message+=$'\n'"Your local changes have been stashed"
	fi
	Fail "$pending_error_message"
    fi

    if $need_to_pop
    then
	git stash pop --quiet
    fi
}

function gh_clean {
    # g_delete_branches
    Run git reset --hard
    # -f:  Force
    # -d:  Remove directories
    # -x:  Don't read .gitignore and GIT_DIR/info/exclude
    Run git clean -fdx
}

function gh_update {
    if (( $# != 0 ))
    then
	UsageError update "Command takes exactly zero arguments"
    fi

    GetBranch
    local branch="$OUT"

    PendingUpstreamCommits "$branch"
    local upstream="$OUT"

    CaptureStd git rev-parse "$branch"
    local branch_commit="$OUT"

    CaptureStd git rev-parse "$upstream"
    local upstream_commit="$OUT"

    if test "$upstream_commit" == "$branch_commit"
    then
	# There are no upstream changes
	echo "There were no upstream changes"
	return
    fi

    CaptureStd git stash --include-untracked
    local stash_output="$OUT"

    git rebase -q "$upstream"

    if ! [[ "$stash_output" =~ ^'No local changes to save'$ ]]
    then
        # Cannot be --quiet, since it swallows warnings about conflicts.
	RunOrFail git stash pop
    fi
}

function gh_diff {
    Stage
    
    if (( $# == 0 ))
    then
	# Only run diffuse if we're running X, diffuse is installed, and stdout
	# is a terminal (otherwise stdout could be 'less' or a file).
	if test -v DISPLAY && type diffuse &> /dev/null && test -t 1
	then
	    # Make it easy to modify while looking at diff
	    diffuse -m &
	else
	    git diff HEAD
	fi
    elif (( $# == 1 )) && test "$1" == -m
    then
        local merge_base=$(git merge-base origin/master HEAD)
        git diff "$merge_base" HEAD
    else
	git diff "$@"
    fi
}

function gh_head {
    gh_checkout master
    gh_update
}

function gh_history {
    Stage
    if type gitk &> /dev/null
    then
	gitk
    else
	git log
    fi
}

function TryGetPullRequest {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    
    ToJsonString "$owner"
    local owner_json="$OUT"

    ToJsonString "$repo"
    local repo_json="$OUT"

    local query="query {
  repository(owner:$owner_json name:$repo_json) {
    pullRequest(number:$number) {
      assignees(first:100) {
        nodes {
          login
        }
      }
      reviewRequests(first: 100) {
        nodes {
          reviewer {
            login
          }
        }
      }
      comments(last:1) {
        pageInfo {
          endCursor
        }
      }
      headRef {
        name
        target {
          oid
        }
      }
      mergeable
      merged
      state
      url
    }
  }
}"

    QueryGraph "$endpoint" "$query"
    local json="$OUT"

    Jq ".data.repository.pullRequest" "$json"
    if test "$OUT" == null
    then
	return 1
    fi
    json="$OUT"

    JqRaw ".state" "$json"
    local state="$OUT"
    case "$state" in
	OPEN) : ;;
	CLOSED|MERGED)
	    # E.g. the head commit is not available if closed, which we return
	    # below (may not be needed?), therefore bail out here.
	    Fail "Pull request is $state"
	    ;;
	*) Fail "Pull request in bad state '$state'" ;;
    esac

    JqRaw ".headRef.name" "$json"
    local branch="$OUT"
    if ! [[ "$branch" =~ ^[a-zA-Z0-9_/-]+$ ]]
    then
	Fail "Unexpected name of branch: '$branch'"
    elif test "$branch" == master
    then
	Fail "Pull request bound to master, refusing to proceed"
    fi

    JqRaw ".headRef.target.oid" "$json"
    local head_commit="$OUT"
    if ! [[ "$head_commit" =~ ^[a-f0-9]{40}$ ]]
    then
	Fail "Unexpected format of head commit: '$head_commit'"
    fi

    JqRaw ".url" "$json"
    local url="$OUT"
    if ! [[ "$url" =~ ^http ]]
    then
	Fail "Unexpected format of pull request URL: '$url'"
    fi

    Jq ".comments" "$json"
    local last_comments_id="$OUT"
    if test "$last_comments_id" != null
    then
	JqRaw ".comments.pageInfo.endCursor" "$json"
	last_comment_id="$OUT"
    fi

    JqRawLines ".assignees.nodes[].login" "$json"
    local -a assignees=("${OUTA[@]}")

    # This didn't list the reviewers on one occasion, something the explorer
    # confirmed. Perhaps REST API would have worked? Reviewer showed on the web
    # page.
    JqRawLines ".reviewRequests.nodes[].reviewer.login" "$json"
    local -a reviewers=("${OUTA[@]}")

    OUT="$branch"
    OUT2="$head_commit"
    OUT3="$url"
    OUT4="$last_comment_id"
    OUTA=("${assignees[@]}")
    OUTA2=("${reviewers[@]}")
}

function GetPullRequest {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"

    if ! TryGetPullRequest "$@"
    then
	Fail "There is no pull request $number at $endpoint:$owner/$repo"
    fi
}

function FindEndpointIfPullRequestUrl {
    local url="$1"

    # Example: https://github.com/vespa-engine/vespa/pull/3937#ignored
    if ! [[ "$url" =~ ^https://([a-zA-Z0-9.-]+)(/[^?#]+)?/([^/]+)/([^/]+)/pull/([0-9]+)(\#.*)?$ ]]
    then
	return 1
    fi

    # Remove any suffix #foo
    local sub_url="${url%${BASH_REMATCH[6]}}"

    local authority="${BASH_REMATCH[1]}"
    local owner="${BASH_REMATCH[3]}"
    local repo="${BASH_REMATCH[4]}"
    local number="${BASH_REMATCH[5]}"

    ToJsonString "$owner"
    local owner_json="$OUT"

    ToJsonString "$repo"
    local repo_json="$OUT"

    local query="query {
  repository(owner:$owner_json name:$repo_json) {
    pullRequest(number:$number) {
      url
    }
  }
}"

    GetEndpoints
    local -a endpoints=("${OUTA[@]}")
    
    local endpoint
    for endpoint in "${endpoints[@]}"
    do
	if TryGetPullRequest "$endpoint" "$owner" "$repo" "$number"
	then
	    local branch="$OUT"
	    local canonical_url="$OUT3"

	    if test "$sub_url" != "$canonical_url"
	    then
		Fail "URL '$url' does not match pull request url " \
		     "'$canonical_url'"
	    fi

	    OUT="$endpoint"
	    OUT2="$owner"
	    OUT3="$repo"
	    OUT4="$number"
	    OUT5="$branch"
	    return 0
	fi
    done

    Fail "No endpoint in config file '$CONFIG_FILE' owns '$url'"
}

function ChecksAt {
    local json="$1"
    shift
    local -a fields=("$@")

    if ! Jq ".checks" "$json"
    then
	Fail "Failed to access .checks of '$json'"
    fi
    local checks_json="$OUT"

    if test "$checks_json" == null
    then
	local has_checks=false
	local -a checks=()
    else
	local has_checks=true
	JqRawLines ".checks[]" "$json"
	local -a checks=("${OUTA[@]}")
    fi

    local has_field_value=true

    local field
    for field in "${fields[@]}"
    do
	ToJsonString "$field"
	local field_json="$OUT"

	if ! Jq ".$field_json" "$json"
	then
	    Fail "Failed to access '$field_json' of '$json'"
	fi
	json="$OUT"

	if test "$json" == null
	then
	    has_field_value=false
	    break
	else
	    has_field_value=true
	fi
    done

    OUT="$has_checks"
    OUT2="$has_field_value"
    OUT3="$json"
    OUTA=("${checks[@]}")
}

function GetChecksFor {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"

    ReadConfigAsString
    local json="$OUT"

    local -a root_fields=(endpoints "$endpoint")
    local -a endpoint_fields=(owners "$owner")
    local -a owner_fields=(repos "$repo")
    local -a repo_fields=()

    local -a checks=()

    local field
    for field in root endpoint owner repo
    do
	local -n fields="${field}_fields"

	ChecksAt "$json" "${fields[@]}"
	local has_checks="$OUT"
	if $has_checks
	then
	    checks=("${OUTA[@]}")
	fi

	local has_field_value="$OUT2"
	if $has_field_value
	then
	    json="$OUT3"
	else
	    break
	fi

	# Without this, the next iteration of the loop will think we're setting
	# the -n (nameref) attribute on endpoint_fields (and warn that -n
	# cannot be set on an array).
	unset -n fields
    done

    OUTA=("${checks[@]}")
}

function CheckStatus {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    local commit="$5"
    local last_comment_id="$6"

    ToJsonString "$owner"
    local owner_json="$OUT"

    ToJsonString "$repo"
    local repo_json="$OUT"

    local query="query {
  repository(owner:$owner_json name:$repo_json) {
    pullRequest(number:$number) {
      comments(last:1) {
        pageInfo {
          endCursor
        }
      }
      state
      merged
      mergeable
      headRef {
        name
      }
      commits(last: 1) {
        nodes {
          commit {
            oid
            status {
              state
              contexts {
                context
                description
                state
                targetUrl
              }
            }
          }
        }
      }
    }
  }
}"

    QueryGraph "$endpoint" "$query"
    local json="$OUT"

    Jq ".data.repository.pullRequest" "$json"
    json="$OUT"

    JqRaw ".state" "$json"
    local state="$OUT"

    case "$state" in
	OPEN) : ;;
	null)
	    OUT="The state of the pull request is not yet known"
	    return 1
	    ;;
	*) Fail "State is not OPEN: '$state'" ;;
    esac

    JqRaw ".merged" "$json"
    local merged="$OUT"

    case "$merged" in
	false) : ;;
	null)
	    OUT="Checking whether pull request has been merged"
	    return 1
	    ;;
	true) Fail "Pull request has been merged" ;;
	*) Fail "Unknown merged status '$merged'" ;;
    esac

    JqRaw ".mergeable" "$json"
    local mergeable="$OUT"

    case "$mergeable" in
	MERGEABLE) : ;;
	CONFLICTING)
	    Fail "Pull requests is conflicting with origin/master"
	    ;;
	null|UNKNOWN)
	    OUT="Checking for ability to automatically merge"
	    return 1
	    ;;
	*) Fail "Unknown mergeable status '$mergeable'" ;;
    esac

    JqRaw ".headRef.name" "$json"
    local branch="$OUT"

    Jq ".comments" "$json"
    local current_last_comment_id="$OUT"
    if test "$current_last_comments_id" != null
    then
	JqRaw ".comments.pageInfo.endCursor" "$json"
	current_last_comment_id="$OUT"
    fi
    if test "$current_last_comment_id" != "$last_comment_id"
    then
	Fail "Comments have been added, aborting status check"
    fi

    Jq ".commits.nodes[].commit" "$json"
    json="$OUT"

    Jq ".status" "$json"
    local status="$OUT"
    if test "$status" == "null"
    then
	local -a checks=()
    else
	JqRawLines ".status.contexts[].context" "$json"
	local -a checks=("${OUTA[@]}")
    fi

    GetChecksFor "$endpoint" "$owner" "$repo"
    local -a required_checks=("${OUTA[@]}")

    local required_check=""
    for required_check in "${required_checks[@]}"
    do
	local check_passes=false

	local check=""
	for check in "${checks[@]}"
	do
	    if [[ "$check" =~ $required_check ]]
	    then
		ToJsonString "$check"
		local check_json="$OUT"

		JqRaw ".status.contexts[] | select(.context == $check_json)" \
		      "$json"
		local context_json="$OUT"

		JqRaw ".state" "$context_json"
		local context_state="$OUT"

		JqRaw ".description" "$context_json"
		local description="$OUT"

		JqRaw ".targetUrl" "$context_json"
		local target_url="$OUT"

		case "$context_state" in
		    SUCCESS) : ;;
		    null|PENDING)
			OUT="Check not finished: $description"$'\n'
			OUT+="See $target_url for details"
			return 1
			;;
		    *) Fail "Bad check status: '$context_state'"
		esac

		check_passes=true
		break
	    fi
	done

	if ! $check_passes
	then
	    OUT="Waiting for check matching '$required_check'"
	    return 1
	fi
    done

    JqRaw ".status.state" "$json"
    local status_state="$OUT"

    case "$status_state" in
	SUCCESS) : ;;
	null)
	    # If there are no required checks, status may be null.
	    if (( ${#required_checks[@]} > 0 ))
	    then
		OUT="Overall status not yet determined"
		return 1
	    fi
	    ;;
	*) Fail "Bad overall check state: '$status_state'" ;;
    esac

    JqRaw ".oid" "$json"
    local head_commit="$OUT"

    if test "$head_commit" != "$commit"
    then
	Fail "Additional commits have been added, refusing to continue"
    fi
}

function WaitForChecks {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    local commit="$5"
    local last_comment_id="$6"

    local -i sleep_seconds=1
    local pending_message=""
    local previous_message=""
    while ! CheckStatus "$endpoint" "$owner" "$repo" "$number" "$commit" \
	    "$last_comment_id"
    do
	local message="$OUT"
	if test "$message" == ""
	then
	    Fail "Internal error: Check status failed but without message"
	fi

	if test "$message" != "$previous_message"
	then
	    printf "%s%s..." "$pending_message" "$message"
	    pending_message=$'\n'
	    sleep_seconds=1
	else
	    printf "."

	    if (( sleep_seconds < 10 ))
	    then
		sleep_seconds+=1
	    fi
	fi

	previous_message="$message"
	sleep "$sleep_seconds"
    done

    printf "%s%s\n" "$pending_message" "All checks pass"
}

function AssignPullRequest {
    endpoint="$1"
    owner="$2"
    repo="$3"
    number="$4"
    assignee="$5"

    ToJsonString "$assignee"
    local assignee_json="$OUT"
    local data="{\"assignees\": [ $assignee_json ]}"

    local path="/repos/$owner/$repo/issues/$number/assignees"
    PostRest "$endpoint" "$path" -d "$data"

    # Unfortunately, even if assignee is bogus, the POST returns 201 OK.  The
    # assignee list will not be updated, so the only way to check is if
    # assignee is in $out, or do an explicit check on whether assignee is
    # assigned. We'll just assume it's OK. But we also verify the assignee is
    # valid before the POST.
}

function AddPullRequestComment {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    local comment="$5"

    ToJsonString "$comment"
    local comment_json="$OUT"
    local data="{\"body\": $comment_json }"

    local path="/repos/$owner/$repo/issues/$number/comments"
    PostRest "$endpoint" "$path" -d "$data"
}

function Ptal {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    shift 4
    local -a assignees=("$@")

    if (( ${#assignees[@]} == 0 ))
    then
	Fail "There are no assignees to ask for PTAL"
    fi

    local comment="Please take another look"
    local assignee
    for assignee in "${assignees[@]}"
    do
	comment+=" @$assignee"
    done

    AddPullRequestComment "$endpoint" "$owner" "$repo" "$number" "$comment"
}

function ApprovePullRequest {
    endpoint="$1"
    owner="$2"
    repo="$3"
    number="$4"
    commit="$5"

    local data="{\"commit_id\": \"$commit\", \"event\": \"APPROVE\"}"
    PostRest "$endpoint" "/repos/$owner/$repo/pulls/$number/reviews" -d "$data"
}

function MergePullRequest {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    local commit="$5"

    if ! [[ "$number" =~ ^[0-9]+$ ]]
    then
	Fail "Bad PR number: '$pr_number'"
    elif ! [[ "$commit" =~ ^[0-9a-f]{40}$ ]]
    then
	Fail "Bad HEAD commit: '$commit'"
    fi

    PutRest "$endpoint" "/repos/$owner/$repo/pulls/$number/merge" \
	    -d "{ \"sha\": \"$commit\" }"
}

function LookupReviewers {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local reviewers="$4"

    SplitBy "$reviewers" ,
    local -a reviewers_array=("${OUTA[@]}")

    reviewers=""

    local reviewer
    for reviewer in "${reviewers_array[@]}"
    do
	LookupReviewer "$endpoint" "$owner" "$repo" "$reviewer"

	if test -z "$reviewers"
	then
	    reviewers="$OUT"
	else
	    reviewers+=,"$OUT"
	fi
    done

    OUT="$reviewers"
}

function WaitForChecksThen {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"

    local approve="$5"
    local comment="$6"
    local assignee="$7" # Possibly bad
    local merge="$8"
    local ptal="$9"
    local reviewers_string="${10}" # Possibly bad

    if test "$assignee" != ""
    then
	LookupAssignee "$endpoint" "$owner" "$repo" "$assignee"
	assignee="$OUT"
    fi

    if test "$reviewers_string" != ""
    then
	LookupReviewers "$endpoint" "$owner" "$repo" "$reviewers_string"
	reviewers_string="$OUT"
    fi

    GetPullRequest "$endpoint" "$owner" "$repo" "$number"
    local branch="$OUT"
    local commit="$OUT2"
    local last_comment_id="$OUT4"
    local -a assignees=("${OUTA[@]}")
    local -a current_reviewers=("${OUTA2[@]}")

    WaitForChecks "$endpoint" "$owner" "$repo" "$number" "$commit" \
		  "$last_comment_id"

    if test "$assignee" != ""
    then
	AssignPullRequest "$endpoint" "$owner" "$repo" "$number" "$assignee"
	echo "$assignee assigned to PR"
    fi

    if test "$reviewers_string" != ""
    then
	AddReviewers "$endpoint" "$owner" "$repo" "$number" "$reviewers_string"
	echo "$reviewers_string set to review PR"
    fi

    if test "$comment" != ""
    then
	AddPullRequestComment "$endpoint" "$owner" "$repo" "$number" "$comment"
    fi

    if $ptal
    then
	ResolveEndpoint "$endpoint"
	local user="$OUT2"

	local -A ptal_logins=()
	local login
	for login in "${assignees[@]}" "${current_reviewers[@]}"
	do
	    if test "$login" != "$user"
	    then
		ptal_logins["$login"]=1
	    fi
	done

	if (( ${#ptal_logins[@]} == 0 ))
	then
	    UsageError wait "There are no reviewers to ask for PTAL from"
	fi

	# Printing happens in function
	Ptal "$endpoint" "$owner" "$repo" "$number" "${!ptal_logins[@]}"
	echo "Asked for PTAL from: ${!ptal_logins[*]}"
    fi

    if $approve
    then
	ApprovePullRequest "$endpoint" "$owner" "$repo" "$number" "$commit"
	echo "Pull request approved"
    fi

    if $merge
    then
	MergePullRequest "$endpoint" "$owner" "$repo" "$number" "$commit"
	echo "Pull request merged"

	git push --quiet --delete origin "$branch"
	
	GetBranch
	local wd_branch="$OUT"

	if test "$wd_branch" == "$branch"
	then
	    if ! git checkout --quiet master
	    then
		Fail "Failed to check out master"
	    fi

	    if ! git pull --quiet --rebase
	    then
		Fail "Failed to pull master"
	    fi

	    echo "master checked out and updated"

	    if ! git branch --quiet -d "$wd_branch"
	    then
		Fail "Failed to delete local branch '$wd_branch'"
	    fi

	    echo "Deleted local branch '$wd_branch'"
	fi
    fi

    echo Success
}

function GetMentionableUsers {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"

    ToJsonString "$owner"
    local owner_json="$OUT"

    ToJsonString "$repo"
    local repo_json="$OUT"

    local query_prefix="query {
  repository(owner:$owner_json name:$repo_json) {
    mentionableUsers(first:100"

    local query_suffix=") {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        login
        name
      }
    }
  }
}"

    QueryGraphList "$endpoint" "$query_prefix" "$query_suffix" \
		   ".data.repository.mentionableUsers"
    local mentionable_users="$OUT"

    # mentionable_users='{"login":"x1","name":"y1 z1"}
    # {"login":"x2","name":"y2 z2"}
    # ...
    # '
    OUT="$mentionable_users"
}

function LookupAssignee {
    LookupLogin assignee "$@"
}

function LookupReviewer {
    LookupLogin reviewer "$@"
}

function LookupLogin {
    local description="$1" # e.g. reviewer or assignee
    shift
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local name_or_login="$4"

    if test "$name_or_login" == ""
    then
	Fail "${description^} cannot be empty"
    fi

    GetMentionableUsers "$endpoint" "$owner" "$repo"
    local users_arrayish="$OUT"

    ToJsonString "$name_or_login"
    local name_or_login_json="$OUT"

    JqRawLines "select(.login == $name_or_login_json) | .login" \
	       "$users_arrayish"
    local -a matches=("${OUTA[@]}")

    case "${#matches[@]}" in
	0)
	    Jq "select(.name != null) | select(.name | test($name_or_login_json; \"i\"))" \
	       "$users_arrayish"
	    local result="$OUT"
	    
	    JqRawLines ".login" "$result"
	    matches=("${OUTA[@]}")

	    case "${#matches[@]}" in
		0) Fail "No $description found with login '$name_or_login' " \
			"nor name matching '$name_or_login'" ;;
		1)
		    local login="${matches[0]}"

		    JqRaw ".name" "$result"
		    local name="$OUT"
		    
		    read -n1 -p "Found '$name' ($login) matching '$name_or_login', ok? [Y/n] "
		    if test "$REPLY" != ""
		    then
			echo
			if test "$REPLY" != y
			then
			    exit 1
			fi
		    fi
	    	    ;;
		*) Fail "Found several ${description}s with names matching " \
			"'$name_or_login': ${matches[*]}" ;;
	    esac
	    ;;
	1) local login="${matches[0]}" ;;
	*) Fail "Found several ${description}s with login '$name_or_login'!?" ;;
    esac

    if ! [[ "$login" =~ ^[a-z0-9]+$ ]]
    then
	Fail "Bad login name '$login' found for $description '$name_or_login'"
    fi

    OUT="$login"
}

function gh_reviewers {
    GitHubInfoFromOrigin
    local endpoint="$OUT"
    local owner="$OUT2"
    local repo="$OUT3"
    local ssh_url="$OUT4"

    GetBranch
    local branch="$OUT"

    if ! GetPullRequestNumber "$endpoint" "$owner" "$repo" "$branch"
    then
	Fail "There's no PR number associated with working directory"
    fi
    local number="$OUT"

    GetReviewers "$endpoint" "$owner" "$repo" "$number"

    printf "%s\n" "$OUT"
}

function GetReviewers {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local pr_number="$4"
    shift 4
    
    local path=/repos/"$owner"/"$repo"/pulls/"$pr_number"/requested_reviewers
    GetRest "$endpoint" "$path"
    local json="$OUT"
}

function gh_exec {
    "$@"
}

function AddReviewers {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local pr_number="$4"
    local comma_separated_list_of_reviewers="$5"
    
    SplitBy "$comma_separated_list_of_reviewers" ,
    local -a reviewers=("${OUTA[@]}")

    local escaped_reviewers_list=""

    local reviewer
    for reviewer in "${reviewers[@]}"
    do
	ToJsonString "$reviewer"
	local escaped_reviewer="$OUT"

	if test -z "$escaped_reviewers_list"
	then
	    escaped_reviewers_list="$escaped_reviewer"
	else
	    escaped_reviewers_list+=,"$escaped_reviewer"
	fi
    done

    local data="{\"reviewers\": [ $escaped_reviewers_list ]}"
    local path=/repos/"$owner"/"$repo"/pulls/"$pr_number"/requested_reviewers
    PostRest "$endpoint" "$path" -d "$data"
}

function gh_wait {
    local assignee= approve=false comment= merge=false ptal=false reviewers=
    while (($# > 0))
    do
	case "$1" in
	    -A|--approve|+1|--lgtm)
		approve=true
		shift
		;;
	    -a|--assignee)
		assignee="$2"
		shift 2
		;;
	    -c|--comment)
		comment="$2"
		shift 2
		;;
	    -m|--merge)
		merge=true
		shift
		;;
	    -p|--ptal)
		ptal=true
		shift
		;;
	    -r|--reviewers)
		reviewers="$2"
		shift 2
		;;
	    *)
		break
		;;
	esac
    done

    local wrong_usage=true

    if (( $# == 0 ))
    then
	GitHubInfoFromOrigin
	local endpoint="$OUT"
	local owner="$OUT2"
	local repo="$OUT3"

	GetBranch
	local branch="$OUT"

	if ! GetPullRequestNumber "$endpoint" "$owner" "$repo" "$branch"
	then
	    Fail "There's no pull request associated with working directory"
	fi
	local number="$OUT"
	local url="$OUT2"

	wrong_usage=false
	echo "Found pull request $url"
    elif (( $# == 1 ))
    then
	if PullRequestInfo "$1"
	then
	    local endpoint="$OUT"
	    local owner="$OUT2"
	    local repo="$OUT3"
	    local branch="$OUT4"
	    local number="$OUT5"
	    wrong_usage=false
	fi
    fi

    if $wrong_usage
    then
	UsageError wait "Please specify which pull request to wait for"
    fi

    WaitForChecksThen "$endpoint" "$owner" "$repo" "$number" \
		      "$approve" "$comment" "$assignee" "$merge" "$ptal" \
		      "$reviewers"
}

declare -A UNOFFICIAL_COMMANDS=(
    [b]=gh_branch
    [branch]=gh_branch
    [c]=gh_commands
    [checkout]=gh_checkout
    [co]=gh_checkout
    [di]=gh_diff
    [diff]=gh_diff
    [head]=gh_head
    [hi]=gh_history
    [history]=gh_history
    [i]=gh_info
    [info]=gh_info
    [is-clean]=IsClean
    [load]=gh_load
    [pending]=gh_pending
    [resolve-pr]=gh_resolve_pr
    [resolve-wd]=gh_resolve_wd
    [revert]=gh_revert
    [s]=gh_status
    [save]=gh_save
    [stage]=Stage
    [status]=gh_status
    [undo]=gh_undo
    [up]=gh_update
    [update]=gh_update)

declare -A DANGEROUS_COMMANDS=(
    [--help]=gh_help
    [-h]=gh_help
    [clean]=gh_clean
    [exec]=gh_exec
    [orgs]=gh_orgs
    [repos]=gh_repos
    [rest]=gh_rest
    [reviewers]=gh_reviewers)

function Main {
    if (( $# == 0 ))
    then
	UsageError '' "No command given"
    fi

    local command="$1"
    shift

    local func="${COMMANDS[$command]}"
    if test "$func" == ""
    then
	func="${UNOFFICIAL_COMMANDS[$command]}"
	if test "$func" == ""
	then
	    func="${DANGEROUS_COMMANDS[$command]}"
	    if test "$func" == ""
	    then
		UsageError '' "No such command '$command'"
	    fi
	fi
    fi

    "$func" "$@"
}

Main "$@"
