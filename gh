#!/bin/bash
#
# Usage: gh

set -e

declare -r CONFIG_FILE="$HOME/.gh"
declare -r PROGRAM="${0##*/}"
declare -r REPOS_FILE="$HOME/.gh-repos"

declare ECHO_COMMAND=false

# Generic global variables to hold output from functions
declare OUT="" OUT2="" OUT3="" OUT4="" OUT5="" OUT6=""
declare -a OUTA=()
declare -A OUTH=()

function Fail {
    local arg
    for arg in "$@"
    do
	printf "%s" "$arg"
    done
    echo

    exit 1
}

function Usage {
    local arg
    for arg in "$@"
    do
	printf "%s\n" "$arg"
    done

    local config_file="${CONFIG_FILE/#$HOME/\~}"
    local repos_file="${REPOS_FILE/#$HOME/\~}"

    cat <<EOF
Usage: $PROGRAM COMMAND [OPTION...] [ARG...]
Git and GitHub tool.

Commands:
  checkin|ci [TITLE]
      Push local change to pull request.
  clone PATTERN
      Clone ENDPOINT:OWNER/REPO matching PATTERN from $repos_file.
  help
  refresh
      Read $config_file and generate $repos_file cache.
EOF

    exit 1
}

function UsageError {
    local command="$1"
    shift
    
    if test "$command" == ""
    then
	local command_text=" of 'gh'"
    else
	local command_text=" of 'gh $command'"
    fi

    Fail "Bad invocation$command_text: " "$@" \
	     $'\n'"See '$PROGRAM help' for details"
}

function EchoCommand {
    printf "%q" "$1"
    shift

    local arg
    for arg in "$@"
    do
	printf " %q" "$arg"
    done
    printf "\\n"
}

function MaybeEchoCommand {
    if $ECHO_COMMAND
    then
	EchoCommand "$@"
    fi
}

function Run {
    MaybeEchoCommand "$@"
    "$@"
}

function Git {
    if ! git "$@"
    then
	Fail "git $* command failed"
    fi
}

function CaptureStd {
    local -a command=("$@")

    local out
    if ! out=$("${command[@]}" 2>&1)
    then
	Fail "Command '${command[*]}' failed unexpectedly: '$out'"
    fi

    OUT="$out"
}

function PrintLines {
    local arg
    for arg in "$@"
    do
	printf "%s\n" "$arg"
    done
}

function Sort {
    local -a elements=("$@")

    OUTA=()
    mapfile -t OUTA <<< "$(PrintLines "${elements[@]}" | sort)"
}

function Match {
    local __Match_regex="$1"
    local __Match_text="$2"
    shift 2

    [[ "$__Match_text" =~ $__Match_regex ]]
    local -i __Match_status="$?"

    if test "$__Match_status" == 0
    then
	local -i __Match_index=1
	local __Match_variable_name
	for __Match_variable_name in "$@"
	do
	    if test "$__Match_variable_name" != ""
	    then
		local -n __Match_variable="$__Match_variable_name"
		__Match_variable="${BASH_REMATCH[$__Match_index]}"
	    fi
	    __Match_index+=1
	done
    elif test "$__Match_status" != 1
    then
	Fail "Bad regular expression: '$__Match_regex'"
    fi

    return "$__Match_status"
}

# Set OUT to a "JSON string" with the value of $1
# 
# Example: The string 'unescaped' defined as follows:
#     local unescaped='This is a "good" example
#     over two lines'
# would be escaped by ToJsonString to:
#     OUT='"This a \"good\" example\nover two lines'
function ToJsonString {
    local string="$1"

    local json_string="$string"
    json_string="${json_string//\\/\\\\}"
    json_string="${json_string//\"/\\\"}"

    local newline=$'\n'
    json_string="${json_string//$newline/\\n}"

    local tab=$'\t'
    json_string="${json_string//$tab/\\t}"

    OUT="\"$json_string\""
}

function Jq {
    local jq_expression="$1"
    local json="$2"
    shift 2

    local out
    if ! out=$(jq "$@" "$jq_expression" <<< "$json" 2>&1)
    then
	Fail "'jq' with expression '$jq_expression' failed on json '$json' " \
	     "printing '$out'"
    fi

    OUT="$out"
}

function JqRaw {
    Jq "$@" -r
}

function JqRawLines {
    local jq_expression="$1"
    local json="$2"

    JqRaw "$jq_expression" "$json"
    local out="$OUT"

    local -a lines=()

    if test "$out" != ""
    then
	while read -r
	do
	    local line="$REPLY"
	    lines+=("$line")
	done <<< "$out"
    fi

    OUTA=("${lines[@]}")
}

function ReadConfigAsString {
    if ! test -e "$CONFIG_FILE"
    then
	Fail "Please make a config file '$CONFIG_FILE'"
    fi

    OUT=$(< "$CONFIG_FILE")
}

function GetEndpoints {
    ReadConfigAsString
    local config="$OUT"

    JqRawLines ".endpoints[].name" "$config"
    # Forward OUTA
}

function ResolveEndpoint {
    local endpoint="$1"

    ReadConfigAsString
    local config="$OUT"

    ToJsonString "$endpoint"
    local name="$OUT"

    Jq ".endpoints[] | select(.name == $name)" "$config"
    local json="$OUT"

    JqRaw .api_authority "$json"
    local api_authority="$OUT"
    local api_authority_regex='^[a-zA-Z0-9.:-]+$'
    if ! [[ "$api_authority" =~ $api_authority_regex ]]
    then
	Fail "Invalid api_authority found in $CONFIG_FILE for endpoint " \
	     "'$endpoint': Is expected to match " \
	     "'$api_authority_regex' but is '$api_authority'"
    fi

    JqRaw .user "$json"
    local user="$OUT"
    local user_regex='^[a-zA-Z0-9_-]+$'
    if ! [[ "$user" =~ $user_regex ]]
    then
	Fail "Invalid user found in $CONFIG_FILE for endpoint " \
	     "'$endpoint': Is expected to match " \
	     "'$user_regex' but is '$user'"
    fi

    JqRaw .token "$json"
    local token="$OUT"
    local token_regex='^[a-zA-Z0-9=]{40}$'
    if ! [[ "$token" =~ $token_regex ]]
    then
	Fail "Invalid token found in $CONFIG_FILE for endpoint " \
	     "'$endpoint': Is expected to match " \
	     "'$token_regex' but is '$token'"
    fi

    if test "$api_authority" == api.github.com
    then
	local rest_url="https://$api_authority"
	local graphql_url="https://$api_authority/graphql"
    else
	# WARNING: This is assuming GitHub Enterprise setup
	local rest_url="https://$api_authority/api/v3"
	local graphql_url="https://$api_authority/api/graphql"
    fi

    OUT="$rest_url"
    OUT2="$user"
    OUT3="$token"
    OUT4="$graphql_url"
}

function Curl {
    local url="$1"
    local token="$2"
    shift 2
    local -a args=("$@")

    local save_dir="$HOME/tmp/gh.cache"
    mkdir -p "$save_dir"

    # Note: Cannot use <<< with tr since it adds a newline
    local url_filename=$(printf "%s" "$url" | tr -c 'a-zA-Z0-9_-' '_')
    local command_file="$save_dir/$url_filename.command"
    local response_file="$save_dir/$url_filename.response"

    local -a command=(
	curl
	--silent
	--fail
	--output "$response_file"
	--write-out "%{http_code}"
	-H "Content-Type: application/json"
	-H "Accept: application/vnd.github.v3+json"
	-H "Authorization: token $token"
	"${args[@]}"
	"$url"
    )

    EchoCommand "${command[@]}" > "$command_file"
    # Avoid stale response_file in case it's not overwritten:
    rm -f "$response_file"

    local -i http_code=0
    MaybeEchoCommand "${command[@]}"
    if http_code=$("${command[@]}")
    then
	:
    else
	local -i status="$?"
	local message="Curl failed with status $status"

	if (( http_code > 0 ))
	then
	    message+=" and HTTP status code $http_code"
	fi

	message+=" for command:"$'\n'$(< "$command_file")

	if test -e "$response_file"
	then
	    local response=$(< "$response_file")
	    if (( ${#response} > 0 ))
	    then
		message+=$'\n'"With HTTP response body:"$'\n'"$response"
	    else
		message+=$'\n'"With empty HTTP response body"
	    fi
	else
	    message+=$'\n'"With absent HTTP response body"
	fi

	Fail "$message"
    fi

    if (( http_code < 200 || http_code >= 300 ))
    then
	Fail "HTTP response code $http_code for command: ${command[*]}"
    fi

    local response
    if ! response=$(< "$response_file")
    then
	Fail "Failed to read '$response_file'"
    fi

    if ! jq . <<< "$response" &> /dev/null
    then
	Fail "Response is invalid JSON: '$response'"
    fi

    OUT="$response"
}

function CurlRest {
    local endpoint="$1"
    local path="$2" # E.g. /repos/user
    shift 2

    ResolveEndpoint "$endpoint"
    local rest_url="$OUT"
    local user="$OUT2"
    local token="$OUT3"

    local url="${rest_url%/}/${path#/}"

    Curl "$url" "$token" "$@"
}

function GetRest {
    CurlRest "$@" -X GET 
}

# Usage: PostRest ENDPOINT PATH -d '...' ...
function PostRest {
    CurlRest "$@" -X POST 
}

function PutRest {
    CurlRest "$@" -X PUT
}

function DeleteRest {
    CurlRest "$@" -X DELETE
}

function QueryGraph {
    local endpoint="$1"
    local query="$2"
    shift 2

    ToJsonString "$query"
    local query_json="$OUT"
    local json="{\"query\": $query_json}"

    ResolveEndpoint "$endpoint"
    local user="$OUT2"
    local token="$OUT3"
    local graphql_url="$OUT4"

    Curl "$graphql_url" "$token" "$@" -X POST -d "$json"
    # OUT="$response"
}

function QueryGraphList {
    local endpoint="$1"
    local query_prefix="$2"
    local query_suffix="$3"
    local jq_path="$4"
    shift 4

    local jq_nodes=""

    local cursor_text=""
    while true
    do
	local query="$query_prefix$cursor_text$query_suffix"
	QueryGraph "$endpoint" "$query" "$@"
	local response="$OUT"

	Jq "$jq_path" "$response"
	local graphql_array="$OUT"

	Jq '.nodes[]' "$graphql_array"
	jq_nodes+="$OUT"$'\n'

	Jq .pageInfo.hasNextPage "$graphql_array"
	local has_next_page="$OUT"
	case "$has_next_page" in
	    true) : ;;
	    false) break ;;
	    *)
		Fail "Bad value of hasNextPage for GraphQL array " \
		     "'$graphql_array'"
		;;
	esac

	Jq .pageInfo.endCursor "$graphql_array"
	local end_cursor_json="$OUT"
	cursor_text=" after:$end_cursor_json"
    done

    OUT="$jq_nodes"
}

function GetOrgs {
    local endpoint="$1"

    ResolveEndpoint "$endpoint"
    local user="$OUT2"

    ToJsonString "$user"
    local user_json="$OUT"

    local query="
query {
  user(login:$user_json) {
    organizations(first:100) {
      totalCount
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        name
        login
        url
      }
    }
  }
}
"

    QueryGraph "$endpoint" "$query"
    local orgs_json="$OUT"

    JqRawLines ".data.user.organizations.nodes[].login" "$orgs_json"
    local -a orgs=("${OUTA[@]}")

    OUTA=("${orgs[@]}")
}

function gh_orgs {
    if (( $# != 1 ))
    then
	UsageError orgs "Expected exactly one argument: the endpoint name"
    fi

    local endpoint="$1"

    GetOrgs "$endpoint"
    PrintLines "${OUTA[@]}"
}

function GetRepos {
    local endpoint="$1"
    local owner="$2" # organization or user
    
    local -a repos=()

    ToJsonString "$owner"
    local owner_json="$OUT"

    local after_text=""

    while true
    do
	local query="
query {
  repositoryOwner(login:$owner_json) {
    repositories(first:100$after_text) {
      pageInfo {
        endCursor
        hasNextPage
      }
      nodes {
        name
      }
    }
  }
}"

	QueryGraph "$endpoint" "$query"
	local response_json="$OUT"

	JqRawLines ".data.repositoryOwner.repositories.nodes[].name" \
		   "$response_json"
	repos+=("${OUTA[@]}")

	JqRaw ".data.repositoryOwner.repositories.pageInfo.hasNextPage" \
	      "$response_json"
	local has_next_page="$OUT"

	case "$has_next_page" in
	    true) : ;;
	    false) break ;;
	    *) Fail "Bas hasNextPage value in response: '$has_next_page'" ;;
	esac

	JqRaw ".data.repositoryOwner.repositories.pageInfo.endCursor" \
	      "$response_json"
	local end_cursor="$OUT"

	if ! Match '^[a-zA-Z0-9=]+$' "$end_cursor"
	then
	    Fail "Bas endCursor value in response: '$end_cursor'"
	fi

	ToJsonString "$end_cursor"
	local end_cursor_json="$OUT"
	after_text=" after:$end_cursor_json"
    done

    OUTA=("${repos[@]}")
    Sort "${OUTA[@]}"
}

function gh_repos {
    if (( $# != 2 ))
    then
	UsageError repos "Command takes exactly two arguments"
    fi

    local endpoint="$1"
    local owner="$2"

    GetRepos "$endpoint" "$owner"
    PrintLines "${OUTA[@]}"
}

function gh_refresh {
    if (( $# != 0 ))
    then
	UsageError repos-refresh "Takes exactly 0 arguments"
    fi

    local repos_workfile="$HOME/.gh-repos.tmp"
    > "$repos_workfile"

    GetEndpoints
    local -a endpoints=("${OUTA[@]}")

    local endpoint
    for endpoint in "${endpoints[@]}"
    do
	if [[ "$endpoint" =~ ' ' ]]
	then
	    Fail "The file format assumes endpoint '$endpoint' doesn't " \
		 "doesn't contains space"
	fi

	GetOrgs "$endpoint"
	local -a orgs=("${OUTA[@]}")

	ResolveEndpoint "$endpoint"
	local user="$OUT2"

	local -a owners=("$user" "${orgs[@]}")

	# Hack:
	#  - GraphQL DOESN'T support providing ssh_url for a repo.
	#  - So we must use REST API.
	#  - Either we list all repos with heavy-weight REST API, or
	#  - as we choose to do, we get ssh_url for one repo per endpoint,
	#    and guess the ssh_url for all others.
	local ssh_url_prefix="" ssh_url_suffix=""

	local owner
	for owner in "${owners[@]}"
	do
	    if [[ "$owner" =~ ' ' ]]
	    then
		Fail "The file format assumes owner '$owner' doesn't " \
		     "doesn't contains space"
	    fi

	    GetRepos "$endpoint" "$owner"
	    local -a repos=("${OUTA[@]}")

	    if (( ${#repos[@]} == 0 ))
	    then
		# No point in proceeding
		continue
	    fi

	    if test "$ssh_url_prefix" == ""
	    then
		local example_repo="${repos[0]}"
		GetRest "$endpoint" "/repos/$owner/$example_repo"
		local json="$OUT"

		JqRaw .ssh_url "$json"
		local ssh_url="$OUT"

		# This is a terrible regex.
		local regex="^(.*)$owner/$example_repo(.*)"
		if ! Match "$regex" "$ssh_url" \
		     ssh_url_prefix ssh_url_suffix
		then
		    Fail "Unexpected form of ssh_url doesn't match regex " \
			 "'$regex': '$ssh_url'"
		fi
	    fi

	    local repo
	    for repo in "${repos[@]}"
	    do
		if [[ "$repo" =~ ' ' ]]
		then
		    Fail "The file format assumes repo '$repo' doesn't " \
			 "doesn't contains space"
		fi

		local ssh_url="${ssh_url_prefix}$owner/$repo$ssh_url_suffix"

		if [[ "$ssh_url" =~ ' ' ]]
		then
		    Fail "The file format assumes ssh_url '$ssh_url' doesn't " \
			 "doesn't contains space"
		fi

		printf "%s %s %s %s\n" "$endpoint" "$owner" "$repo" "$ssh_url" \
		       >> "$repos_workfile"
	    done
	done
    done

    mv "$repos_workfile" "$REPOS_FILE"
}

function GitHubInfoFromOrigin {
    local remote_url
    if ! remote_url=$(git remote get-url origin)
    then
	Fail "Failed to get origin remote URL"
    fi

    AssertReposFile

    local endpoint="" owner="" repo="" ssh_url=""
    while read -r endpoint owner repo ssh_url
    do
	if test "$ssh_url" == "$remote_url"
	then
	    OUT="$endpoint"
	    OUT2="$owner"
	    OUT3="$repo"
	    OUT4="$ssh_url"
	    return
	fi
    done < "$REPOS_FILE"

    Fail "Failed to find any repositories matching current git repo"
}	    

function gh_rest {
    if (( $# < 2 ))
    then
	UsageError rest "Takes at least 2 arguments"
    fi

    local endpoint="$1"
    local path="$2"
    shift 2

    GetRest "$endpoint" "$path" "$@"
    printf "%s\n" "$OUT"
}

function AssertReposFile {
    if ! test -r "$REPOS_FILE"
    then
	Fail "Repository summary file not generated, please run " \
	     "'gh repos-refresh'"
    fi
}

function gh_clone {
    if (( $# != 1 ))
    then
	UsageError clone "Exactly one argument expected"
    fi
    local pattern="$1"

    AssertReposFile

    local -a matched_specs=()
    local -a matched_lines=()
    local endpoint owner repo ssh_url
    while read -r endpoint owner repo ssh_url
    do
	local spec="$endpoint:$owner/$repo"
	if [[ "$spec" =~ $pattern ]]
	then
	    matched_specs+=("$spec")
	    matched_lines+=("$endpoint $owner $repo $ssh_url")
	fi
    done < "$REPOS_FILE"

    local -i num_matches="${#matched_lines[@]}"
    case "$num_matches" in
	0)
	    Fail "Pattern '$pattern' didn't match any 'owner/repositories', " \
		 "see $REPOS_FILE for the list of all repositories"
	    ;;
	1) : ;;
	*)
	    local message=""
	    local spec
	    for spec in "${matched_specs[@]}"
	    do
		message+=$'\n'"$spec"
	    done
	    Fail "Too many repository specs matched '$pattern':$message"
	    ;;
    esac

    read -r endpoint owner repo ssh_url <<< "${matched_lines[0]}"

    Run git clone "$ssh_url" "$owner/$repo"
}

function GetBranch {
    if ! OUT=$(git rev-parse --abbrev-ref HEAD)
    then
	Fail "Failed to get branch with 'git rev-parse --abbrev-ref HEAD'"
    fi
}

function gh_info {
    if (( $# != 0 ))
    then
	UsageError undo "Command takes exactly zero arguments"
    fi

    GitHubInfoFromOrigin
    local endpoint="$OUT"
    local owner="$OUT2"
    local repo="$OUT3"
    local ssh_url="$OUT4"

    GetBranch
    local branch="$OUT"

    if test "$branch" == master
    then
	local branch_text=""
    else
	local branch_text="#$branch"
    fi

    echo "$endpoint:$owner/$repo$branch_text"

    Stage
    Run git status --short
}

function GetGitRootRelative {
    local out
    if ! out=$(git rev-parse --show-cdup 2>&1)
    then
	Fail "Not in a git repository? 'git rev-parse --show-cdup' failed: $out"
    fi

    # If PWD is in root, out is empty.
    local root="${out%/}"
    if ((${#root} == 0))
    then
        root=.
    fi

    if ! [ -d "$root" ]
    then
        Fail "Failed to find root, '$root' not a directory"
    fi

    OUT="$root"
}

function Stage {
    GetGitRootRelative
    local root="$OUT"

    local -a root_args=()
    if [ "$root" == . ]
    then
        # TODO: Shouldn't this be (.) ?
        root_args=()
    elif [[ "$root" =~ ^- ]]
    then
        root_args=(-- "$root")
    else
        root_args=("$root")
    fi

    Run git reset --quiet "${root_args[@]}"
    Run git add --all "${root_args[@]}"
}

function IsClean {
    CaptureStd git status --short
    if test "$OUT" == ""
    then
	return 0
    else
	return 1
    fi
}

function GetPullRequestNumber {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local branch="$4"

    ToJsonString "$owner"
    local owner_json="$OUT"
    ToJsonString "$repo"
    local repo_json="$OUT"
    ToJsonString "$branch"
    local branch_json="$OUT"

    local query="
query {
  repository(owner:$owner_json name: $repo_json) {
    pullRequests(first:1 headRefName: $branch_json) {
      pageInfo {
        hasNextPage
      }
      nodes {
        number
        url
      }
    }
  }
}"
    
    QueryGraph "$endpoint" "$query"
    local json="$OUT"

    JqRaw ".data.repository.pullRequests.pageInfo.hasNextPage" "$json"
    case "$OUT" in
	false) : ;;
	true) Fail "More than one pull requests are open for current branch" ;;
	*) Fail "Failed to get pull request list: '$json'" ;;
    esac

    Jq ".data.repository.pullRequests.nodes | length" "$json"
    case "$OUT" in
	0) return 1 ;;
	1) : ;;
	*) Fail "Failed to get pull request list: '$json'" ;;
    esac

    JqRaw ".data.repository.pullRequests.nodes[].number" "$json"
    local number="$OUT"

    if test "$number" == ""
    then
	return 1
    elif ! [[ "$number" =~ ^[0-9]+$ ]]
    then
	Fail "Failed to get pull request number: '$json'"
    fi

    JqRaw ".data.repository.pullRequests.nodes[].url" "$json"
    local url="$OUT"

    if ! [[ "$url" =~ ^http ]]
    then
	Fail "Failed to get pull request URL: '$json'"
    fi

    OUT="$number"
    OUT2="$url"
}

function RawCreatePullRequest {
    local destination="$1"
    local owner="$2"
    local repo="$3"
    ToJsonString "$4"
    local branch_to_review="$OUT"
    ToJsonString "$5"
    local merge_branch="$OUT"
    ToJsonString "$6"
    local title="$OUT"
    ToJsonString "$7"
    local body="$OUT"

    local data="{
  \"head\": $branch_to_review,
  \"base\": $merge_branch,
  \"title\": $title,
  \"body\": $body
}"

    PostRest "$endpoint" "/repos/$owner/$repo/pulls" -d "$data"
    local json="$OUT"

    Jq .number "$json"
    local number="$OUT"

    JqRaw .html_url "$json"
    local url="$OUT"

    OUT="$number"
    OUT2="$url"
}

function CreatePullRequest {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local branch="$4"

    local destination_branch="master"

    # TODO: If more than 1 commit ahead of origin/master, we should open an
    # editor to specify title and body.

    local title
    title=$(git log -1 --format=%s HEAD)

    local body
    body=$(git log -1 --format=%b HEAD)
    if [[ "$body" =~ ^[' '$'\n'$'\r']+$ ]]
    then
	body=""
    fi

    RawCreatePullRequest "$destination" "$owner" "$repo" "$branch" \
			 "$destination_branch" "$title" "$body"
    # Pass through output variables
}

function gh_checkin {
    local approve=false assignee="" comment="" merge=false ptal=false title=""
    while (( $# > 0 ))
    do
	case "$1" in
	    -A|--approve|+1)
		approve=true
		shift
		;;
	    -a|--assignee)
		assignee="$2"
		shift 2
		;;
	    -c|--comment)
		comment="$2"
		shift 2
		;;
	    -m|--merge)
		merge=true
		shift
		;;
	    -p|--ptal)
		ptal=true
		shift
		;;
	    -t|--title)
		title="$2"
		shift 2
		;;
	    *)
		title="$1"
		shift
		break
	esac
    done

    if (( $# > 0 ))
    then
	UsageError checkin "Too many arguments"
    fi

    GitHubInfoFromOrigin
    local endpoint="$OUT"
    local owner="$OUT2"
    local repo="$OUT3"
    local ssh_url="$OUT4"

    ResolveEndpoint "$endpoint"
    local rest_url="$OUT"
    local user="$OUT2"
    local token="$OUT3"
    local graphql_url="$OUT4"

    local is_clean=""

    GetBranch
    local branch="$OUT"

    if test "$branch" == master
    then
	if IsClean
	then
	    Fail "On master branch, and there's nothing to commit"
	fi
	is_clean=false

	branch="${title,,}"
	branch=$(printf "%s" "$branch" | tr ' ' - | tr -Cd '[[:alnum:]-]')
	if test "$branch" == ""
	then
	    Fail "Failed to find a good branch name from the title '$title'"
	fi
	branch="$user/$branch"

	Stage
	git stash save --quiet --include-untracked
	git checkout --quiet -b "$branch"
	git stash pop --quiet
    fi

    if test "$is_clean" == false || ! IsClean
    then
	local -a args=()
	if test "$title" != ""
	then
	    args+=(-m "$title")
	fi

	Stage
        git commit --quiet "${args[@]}"
    fi
    
    git push --quiet origin "$branch"

    if GetPullRequestNumber "$endpoint" "$owner" "$repo" "$branch"
    then
	local number="$OUT"
	local url="$OUT2"
	echo "Found pull request $url"
    else
	CreatePullRequest "$endpoint" "$owner" "$repo" "$branch"
	local number="$OUT"
	local url="$OUT2"
	echo "Created pull request $url"
    fi

    if test "$assignee" != ""
    then
	LookupAssignee "$endpoint" "$owner" "$repo" "$assignee"
	assignee="$OUT"
    fi

    WaitForChecksThen "$endpoint" "$owner" "$repo" "$number" \
		      "$approve" "$comment" "$assignee" "$merge" "$ptal"
}

function gh_undo {
    if (( $# > 0 ))
    then
	UsageError undo "Command takes exactly zero arguments"
    fi

    git reset --soft HEAD^
    Stage
}

function gh_checkout {
    if (( $# != 1 ))
    then
	UsageError undo "Command takes exactly one argument"
    fi
    local branch="$1"

    if IsClean
    then
	git checkout --quiet "$branch"
    else
	git stash save --quiet
	git checkout --quiet "$branch"
	git stash pop --quiet
    fi
}

function gh_update {
    if (( $# != 0 ))
    then
	UsageError undo "Command takes exactly zero arguments"
    fi

    GetBranch
    local branch="$OUT"

    CaptureStd git stash --include-untracked
    local stash_output="$OUT"

    if [ "$branch" == master ]
    then
	git pull --quiet --rebase
    else
	Fail "Refuse to update non-master branch"
    fi

    if ! [[ "$stash_output" =~ ^'No local changes to save'$ ]]
    then
        # Cannot be --quiet, since it swallows warnings about conflicts.
	Run git stash pop
    fi

    Stage
    gh_info
}

function gh_diff {
    Stage

    if (( $# == 0 ))
    then
	git diff HEAD
    else
	git diff "$@"
    fi
}

function gh_head {
    gh_checkout master
    gh_update
}

function TryGetPullRequest {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    
    ToJsonString "$owner"
    local owner_json="$OUT"

    ToJsonString "$repo"
    local repo_json="$OUT"

    local query="query {
  repository(owner:$owner_json name:$repo_json) {
    pullRequest(number:$number) {
      assignees(first:100) {
        nodes {
          login
        }
      }
      comments(last:1) {
        pageInfo {
          endCursor
        }
      }
      headRef {
        name
        target {
          oid
        }
      }
      mergeable
      merged
      state
      url
    }
  }
}"

    QueryGraph "$endpoint" "$query"
    local json="$OUT"

    Jq ".data.repository.pullRequest" "$json"
    if test "$OUT" == null
    then
	return 1
    fi

    JqRaw ".data.repository.pullRequest.headRef.name" "$json"
    local branch="$OUT"
    if ! [[ "$branch" =~ ^[a-zA-Z0-9_/-]+$ ]]
    then
	Fail "Unexpected name of branch: '$branch'"
    elif test "$branch" == master
    then
	Fail "Pull request bound to master, refusing to proceed"
    fi

    JqRaw ".data.repository.pullRequest.headRef.target.oid" "$json"
    local head_commit="$OUT"
    if ! [[ "$head_commit" =~ ^[a-f0-9]{40}$ ]]
    then
	Fail "Unexpected format of head commit: '$head_commit'"
    fi

    JqRaw ".data.repository.pullRequest.url" "$json"
    local url="$OUT"
    if ! [[ "$url" =~ ^http ]]
    then
	Fail "Unexpected format of pull request URL: '$url'"
    fi

    Jq ".data.repository.pullRequest.comments" "$json"
    local last_comments_id="$OUT"
    if test "$last_comments_id" != null
    then
	JqRaw ".data.repository.pullRequest.comments.pageInfo.endCursor" "$json"
	last_comment_id="$OUT"
    fi

    JqRawLines ".data.repository.pullRequest.assignees.nodes[].login" "$json"
    local -a assignees=("${OUTA[@]}")

    OUT="$branch"
    OUT2="$head_commit"
    OUT3="$url"
    OUT4="$last_comment_id"
    OUTA=("${assignees[@]}")
}

function GetPullRequest {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"

    if ! TryGetPullRequest "$@"
    then
	Fail "There is no pull request $number at $endpoint:$owner/$repo"
    fi
}

function FindEndpointIfPullRequestUrl {
    local url="$1"

    # Example: https://github.com/vespa-engine/vespa/pull/3937
    if ! [[ "$url" =~ ^https://([a-zA-Z0-9.-]+)(/[^?#]+)?/([^/]+)/([^/]+)/pull/([0-9]+)$ ]]
    then
	return 1
    fi

    local authority="${BASH_REMATCH[1]}"
    local owner="${BASH_REMATCH[3]}"
    local repo="${BASH_REMATCH[4]}"
    local number="${BASH_REMATCH[5]}"

    ToJsonString "$owner"
    local owner_json="$OUT"

    ToJsonString "$repo"
    local repo_json="$OUT"

    local query="query {
  repository(owner:$owner_json name:$repo_json) {
    pullRequest(number:$number) {
      url
    }
  }
}"

    GetEndpoints
    local -a endpoints=("${OUTA[@]}")
    
    local endpoint
    for endpoint in "${endpoints[@]}"
    do
	if TryGetPullRequest "$endpoint" "$owner" "$repo" "$number"
	then
	    local canonical_url="$OUT3"
	    if test "$url" != "$canonical_url"
	    then
		Fail "URL '$url' does not match pull request url " \
		     "'$canonical_url'"
	    fi

	    OUT="$endpoint"
	    OUT2="$owner"
	    OUT3="$repo"
	    OUT4="$number"
	    return 0
	fi
    done

    Fail "No endpoint in config file '$CONFIG_FILE' owns '$url'"
}

function GetChecksFor {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"

    ReadConfigAsString
    local config_json="$OUT"

    ToJsonString "$endpoint"
    local endpoint_json="$OUT"

    Jq ".endpoints[] | select(.name == $endpoint_json)" "$config_json"
    local selected_endpoint_json="$OUT"

    if test "$selected_endpoint_json" == ""
    then
	Fail "There's no specification of '$endpoint' in '$CONFIG_FILE'"
    fi

    local -a checks=()

    Jq ".checks" "$selected_endpoint_json"
    local endpoint_checks_string="$OUT"
    if test "$endpoint_checks_string" != null
    then
	Jq .checks "$selected_endpoint_json"
	if test "$OUT" != null
	then
	    JqRawLines ".checks[]" "$selected_endpoint_json"
	    checks=("${OUTA[@]}")
	fi
    fi

    ToJsonString "$owner"
    local owner_json="$OUT"

    Jq .owners "$selected_endpoint_json"
    if test "$OUT" != null
    then
	Jq ".owners[] | select(.name == $owner_json)" "$selected_endpoint_json"
	local selected_owner_json="$OUT"
	if test "$selected_owner_json" != ""
	then
	    Jq ".checks" "$selected_owner_json"
	    local owner_checks_string="$OUT"
	    if test "$owner_checks_string" != null
	    then
		Jq .checks "$selected_owner_json"
		if test "$OUT" != ""
		then
		    JqRawLines ".checks[]" "$selected_owner_json"
		    checks=("${OUTA[@]}")
		fi
	    fi

	    ToJsonString "$repo"
	    local repo_json="$OUT"

	    Jq .repos "$selected_owner_json"
	    if test "$OUT" != null
	    then
		Jq ".repos[] | select(.name == $repo_json)" "$selected_owner_json"
		local selected_repo_json="$OUT"
		if test "$selected_repo_json" != ""
		then
		    Jq ".checks" "$selected_repo_json"
		    if test "$OUT" != null
		    then
			JqRawLines ".checks[]" "$selected_repo_json"
			checks=("${OUTA[@]}")
		    fi
		fi
	    fi
	fi
    fi

    OUTA=("${checks[@]}")
}

function CheckStatus {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    local commit="$5"
    local last_comment_id="$6"

    ToJsonString "$owner"
    local owner_json="$OUT"

    ToJsonString "$repo"
    local repo_json="$OUT"

    local query="query {
  repository(owner:$owner_json name:$repo_json) {
    pullRequest(number:$number) {
      comments(last:1) {
        pageInfo {
          endCursor
        }
      }
      state
      merged
      mergeable
      headRef {
        name
      }
      commits(last: 1) {
        nodes {
          commit {
            oid
            status {
              state
              contexts {
                context
                description
                state
                targetUrl
              }
            }
          }
        }
      }
    }
  }
}"

    QueryGraph "$endpoint" "$query"
    local json="$OUT"

    Jq ".data.repository.pullRequest" "$json"
    json="$OUT"

    JqRaw ".state" "$json"
    local state="$OUT"

    case "$state" in
	OPEN) : ;;
	null)
	    OUT="The state of the pull request is not yet known"
	    return 1
	    ;;
	*) Fail "State is not OPEN: '$state'" ;;
    esac

    JqRaw ".merged" "$json"
    local merged="$OUT"

    case "$merged" in
	false) : ;;
	null)
	    OUT="Checking whether pull request has been merged"
	    return 1
	    ;;
	true) Fail "Pull request has been merged" ;;
	*) Fail "Unknown merged status '$merged'" ;;
    esac

    JqRaw ".mergeable" "$json"
    local mergeable="$OUT"

    case "$mergeable" in
	MERGEABLE) : ;;
	CONFLICTING)
	    Fail "Pull requests is conflicting with origin/master"
	    ;;
	null)
	    OUT="Checking for ability to automatically merge"
	    return 1
	    ;;
	*) Fail "Unknown mergeable status '$mergeable'" ;;
    esac

    JqRaw ".headRef.name" "$json"
    local branch="$OUT"

    Jq ".comments" "$json"
    local current_last_comment_id="$OUT"
    if test "$current_last_comments_id" != null
    then
	JqRaw ".comments.pageInfo.endCursor" "$json"
	current_last_comment_id="$OUT"
    fi
    if test "$current_last_comment_id" != "$last_comment_id"
    then
	Fail "Comments have been added, aborting status check"
    fi

    Jq ".commits.nodes[].commit" "$json"
    json="$OUT"

    Jq ".status" "$json"
    local status="$OUT"
    if test "$status" == "null"
    then
	local -a checks=()
    else
	JqRawLines ".status.contexts[].context" "$json"
	local -a checks=("${OUTA[@]}")
    fi

    GetChecksFor "$endpoint" "$owner" "$repo"
    local -a required_checks=("${OUTA[@]}")

    local required_check=""
    for required_check in "${required_checks[@]}"
    do
	local check_passes=false

	local check=""
	for check in "${checks[@]}"
	do
	    if [[ "$check" =~ $required_check ]]
	    then
		ToJsonString "$check"
		local check_json="$OUT"

		JqRaw ".status.contexts[] | select(.context == $check_json)" \
		      "$json"
		local context_json="$OUT"

		JqRaw ".state" "$context_json"
		local context_state="$OUT"

		JqRaw ".description" "$context_json"
		local description="$OUT"

		JqRaw ".targetUrl" "$context_json"
		local target_url="$OUT"

		case "$context_state" in
		    SUCCESS) : ;;
		    null|PENDING)
			OUT="Check not finished: $description"$'\n'
			OUT+="See $target_url for details"
			return 1
			;;
		    *) Fail "Bad check status: '$context_state'"
		esac

		check_passes=true
		break
	    fi
	done

	if ! $check_passes
	then
	    OUT="Waiting for check matching '$required_check'"
	    return 1
	fi
    done

    JqRaw ".status.state" "$json"
    local status_state="$OUT"

    case "$status_state" in
	SUCCESS) : ;;
	null)
	    # If there are no required checks, status may be null.
	    if (( ${#required_checks[@]} > 0 ))
	    then
		OUT="Overall status not yet determined"
		return 1
	    fi
	    ;;
	*) Fail "Bad overall check state: '$status_state'" ;;
    esac

    JqRaw ".oid" "$json"
    local head_commit="$OUT"

    if test "$head_commit" != "$commit"
    then
	Fail "Additional commits have been added, refusing to continue"
    fi
}

function WaitForChecks {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    local commit="$5"
    local last_comment_id="$6"

    while ! CheckStatus "$endpoint" "$owner" "$repo" "$number" "$commit" \
	    "$last_comment_id"
    do
	Fail "Not implemented... OUT='$OUT'"
    done

    echo "All checks pass"
}

function AssignPullRequest {
    endpoint="$1"
    owner="$2"
    repo="$3"
    number="$4"
    assignee="$5"

    ToJsonString "$assignee"
    local assignee_json="$OUT"
    local data="{\"assignees\": [ $assignee_json ]}"

    local path="/repos/$owner/$repo/issues/$number/assignees"
    PostRest "$endpoint" "$path" -d "$data"

    # Unfortunately, even if assignee is bogus, the POST returns 201 OK.  The
    # assignee list will not be updated, so the only way to check is if
    # assignee is in $out, or do an explicit check on whether assignee is
    # assigned. We'll just assume it's OK. But we also verify the assignee is
    # valid before the POST.
}

function AddPullRequestComment {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    local comment="$5"

    ToJsonString "$comment"
    local comment_json="$OUT"
    local data="{\"body\": $comment_json }"

    local path="/repos/$owner/$repo/issues/$number/comments"
    PostRest "$endpoint" "$path" -d "$data"
}

function Ptal {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    shift 4
    local -a assignees=("$@")

    if (( ${#assignees[@]} == 0 ))
    then
	Fail "There are no assignees to ask for PTAL"
    fi

    local comment="Please take another look"
    local assignee
    for assignee in "${assignees[@]}"
    do
	comment+=" @$assignee"
    done

    AddPullRequestComment "$endpoint" "$owner" "$repo" "$number" "$comment"
}

function ApprovePullRequest {
    endpoint="$1"
    owner="$2"
    repo="$3"
    number="$4"
    commit="$5"

    local data="{\"commit_id\": \"$commit\", \"event\": \"APPROVE\"}"
    PostRest "$endpoint" "/repos/$owner/$repo/pulls/$number/reviews" -d "$data"
}

function MergePullRequest {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"
    local commit="$5"

    if ! [[ "$number" =~ ^[0-9]+$ ]]
    then
	Fail "Bad PR number: '$pr_number'"
    elif ! [[ "$commit" =~ ^[0-9a-f]{40}$ ]]
    then
	Fail "Bad HEAD commit: '$commit'"
    fi

    PutRest "$endpoint" "/repos/$owner/$repo/pulls/$number/merge" \
	    -d "{ \"sha\": \"$commit\" }"
}

function WaitForChecksThen {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local number="$4"

    local approve="$5"
    local comment="$6"
    local assignee="$7"
    local merge="$8"
    local ptal="$9"

    GetPullRequest "$endpoint" "$owner" "$repo" "$number"
    local branch="$OUT"
    local commit="$OUT2"
    local last_comment_id="$OUT4"
    local -a assignees=("${OUTA[@]}")

    WaitForChecks "$endpoint" "$owner" "$repo" "$number" "$commit" \
		  "$last_comment_id"

    if test "$assignee" != ""
    then
	AssignPullRequest "$endpoint" "$owner" "$repo" "$number" "$assignee"
	echo "$assignee assigned to PR"
    fi

    if test "$comment" != ""
    then
	AddPullRequestComment "$endpoint" "$owner" "$repo" "$number" "$comment"
    fi

    if $ptal
    then
	# Printing happens in function
	Ptal "$endpoint" "$owner" "$repo" "$number" "${assignees[@]}"
	echo "Asked for PTAL from: ${assignees[*]}"
    fi

    if $approve
    then
	ApprovePullRequest "$endpoint" "$owner" "$repo" "$number" "$commit"
	echo "Pull request approved"
    fi

    if $merge
    then
	MergePullRequest "$endpoint" "$owner" "$repo" "$number" "$commit"
	echo "Pull request merged"

	DeleteRest "$endpoint" "/repos/$owner/$repo/git/refs/heads/$branch"
	echo "Branch deleted at $endpoint:$owner/$repo"

	GetBranch
	local wd_branch="$OUT"

	if test "$wd_branch" == "$branch"
	then
	    gh_head
	    echo "Checked out master and pulled"
	    if ! git branch --quiet -d "$wd_branch"
	    then
		Fail "Failed to delete local branch '$wd_branch'"
	    fi
	    echo "Deleted local branch '$wd_branch'"
	fi
    fi

    echo Success
}

function GetMentionableUsers {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"

    ToJsonString "$owner"
    local owner_json="$OUT"

    ToJsonString "$repo"
    local repo_json="$OUT"

    local query_prefix="query {
  repository(owner:$owner_json name:$repo_json) {
    mentionableUsers(first:100"

    local query_suffix=") {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        login
        name
      }
    }
  }
}"

    QueryGraphList "$endpoint" "$query_prefix" "$query_suffix" \
		   ".data.repository.mentionableUsers"
    local mentionable_users="$OUT"

    # mentionable_users='{"login":"x1","name":"y1 z1"}
    # {"login":"x2","name":"y2 z2"}
    # ...
    # '
    OUT="$mentionable_users"
}

function LookupAssignee {
    local endpoint="$1"
    local owner="$2"
    local repo="$3"
    local assignee="$4"

    if test "$assignee" == ""
    then
	Fail "Assignee cannot be empty"
    fi

    GetMentionableUsers "$endpoint" "$owner" "$repo"
    local users_arrayish="$OUT"

    ToJsonString "$assignee"
    local assignee_json="$OUT"

    JqRawLines "select(.login == $assignee_json) | .login" "$users_arrayish"
    local -a matches=("${OUTA[@]}")

    case "${#matches[@]}" in
	0)
	    Jq "select(.name != null) | select(.name | test($assignee_json; \"i\"))" "$users_arrayish"
	    local result="$OUT"
	    
	    JqRawLines ".login" "$result"
	    matches=("${OUTA[@]}")

	    case "${#matches[@]}" in
		0) Fail "No assignee found with login '$assignee' nor " \
			"name matching '$assignee'" ;;
		1)
		    local login="${matches[0]}"

		    JqRaw ".name" "$result"
		    local name="$OUT"
		    
		    read -n1 -p "Found '$name' ($login) matching '$assignee', ok? [Y/n] "
		    if test "$REPLY" != ""
		    then
			echo
			if test "$REPLY" != y
			then
			    exit 1
			fi
		    fi
	    	    ;;
		*) Fail "Found several assignees with names matching " \
			"'$assignee': ${matches[*]}" ;;
	    esac
	    ;;
	1) local login="${matches[0]}" ;;
	*) Fail "Found several assignees with login '$assignees'!?" ;;
    esac

    if ! [[ "$login" =~ ^[a-z]+$ ]]
    then
	Fail "Bad login name '$login' found for assignee '$assignee'"
    fi

    OUT="$login"
}

function gh_wait {
    local assignee= approve=false comment= merge=false ptal=false
    while (($# > 0))
    do
	case "$1" in
	    -A|--approve|+1|--lgtm)
		approve=true
		shift
		;;
	    -a|--assignee)
		assignee="$2"
		shift 2
		;;
	    -c|--comment)
		comment="$2"
		shift 2
		;;
	    -m|--merge)
		merge=true
		shift
		;;
	    -p|--ptal)
		ptal=true
		shift
		;;
	    *)
		break
		;;
	esac
    done

    local wrong_usage=true

    if (( $# == 0 ))
    then
	GitHubInfoFromOrigin
	local endpoint="$OUT"
	local owner="$OUT2"
	local repo="$OUT3"

	GetBranch
	local branch="$OUT"

	if ! GetPullRequestNumber "$endpoint" "$owner" "$repo" "$branch"
	then
	    Fail "There's no pull request associated with working directory"
	fi
	local number="$OUT"
	local url="$OUT2"

	wrong_usage=false
	echo "Found pull request $url"
    elif (( $# == 1 ))
    then
	if [[ "$1" =~ ^[0-9]+$ ]]
	then
	    local number="$1"

	    GitHubInfoFromOrigin
	    local endpoint="$OUT"
	    local owner="$OUT2"
	    local repo="$OUT3"
	    
	    if TryGetPullRequest "$endpoint" "$owner" "$repo" "$number"
	    then
		wrong_usage=false
	    fi
	elif FindEndpointIfPullRequestUrl "$1"
	then
	    local endpoint="$OUT"
	    local owner="$OUT2"
	    local repo="$OUT3"
	    local number="$OUT4"
	    wrong_usage=false
	fi
    fi

    if $wrong_usage
    then
	UsageError "Please specify which pull request to wait for"
    fi

    if test "$assignee" != ""
    then
	LookupAssignee "$endpoint" "$owner" "$repo" "$assignee"
	assignee="$OUT"
    fi

    WaitForChecksThen "$endpoint" "$owner" "$repo" "$number" \
		      "$approve" "$comment" "$assignee" "$merge" "$ptal"
}

function Main {
    if (( $# == 0 ))
    then
	UsageError '' "No command given"
    fi

    local command="$1"
    shift

    # TODO: Require jq
    # TODO: Implement the following commands:
    #  - co
    #  - i (consolidate with gh_info), including staging.

    local -A commands=(
	# Official commands
	[checkin]=gh_checkin
	[ci]=gh_checkin
	[clone]=gh_clone
	[help]=Usage
	[refresh]=gh_refresh
	[wait]=gh_wait

	# Unofficial commands
	[checkout]=gh_checkout
	[co]=gh_checkout
	[di]=gh_diff
	[diff]=gh_diff
	[head]=gh_head
	[i]=gh_info
	[info]=gh_info
	[undo]=gh_undo
	[up]=gh_update
	[update]=gh_update

	# Experimental/debug commands
	[orgs]=gh_orgs
	[repos]=gh_repos
	[rest]=gh_rest
    )

    local func="${commands[$command]}"
    if test "$func" == ""
    then
	UsageError '' "No such command '$command'"
    fi

    "$func" "$@"
}

Main "$@"
